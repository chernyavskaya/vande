{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"test",
				"test_evts_j2\tabc"
			],
			[
				"test_e",
				"test_evts_j1\tabc"
			],
			[
				"tes",
				"test_evts_j2\tabc"
			],
			[
				"num",
				"numpy\tabc"
			],
			[
				"pr",
				"print\t(main_predict.py)"
			],
			[
				"da",
				"dataset\tabc"
			],
			[
				"img-local",
				"img-local-54\t(sample_factory.py)"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "import os\nimport setGPU\nimport numpy as np\n\nimport pofah.util.experiment as ex\nimport pofah.util.input_data_reader as idr\nfrom vae.vae_model import VAE\nfrom vae.vae_highres_model import VAE_HR\nimport pofah.util.sample_factory as sf\n\n# ********************************************************\n#       runtime params\n# ********************************************************\n\nrun_n = 4\ndata_sample = 'img-local-54'\n\nexperiment = ex.Experiment(run_n).setup(model_dir=True)\npaths = sf.SamplePathFactory(experiment, data_sample)\n\n# ********************************************************\n#       read in training data ( images )\n# ********************************************************\n\ndata_reader = idr.InputDataReader(paths.qcd_path)\ntrain_img_j1, train_img_j2 = data_reader.read_images( )\n\n# ********************************************************\n#       prepare training data\n# ********************************************************\n\ntraining_img = np.vstack([train_img_j1,train_img_j2])\nnp.random.shuffle(training_img)\n\n# *******************************************************\n#                       build model\n# *******************************************************\n\nvae = VAE(run=run_n, model_dir=experiment.model_dir, input_size=54)\nvae.build()\n\n# *******************************************************\n#                       train and save\n# *******************************************************\n\nvae.fit(training_img, training_img, epochs=3, verbose=2)\nvae.save_model()\n",
			"file": "main_train.py",
			"file_size": 1493,
			"file_write_time": 132424302710000000,
			"settings":
			{
				"buffer_size": 1493,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import os\n\nimport POfAH.sample_dict as sd\nimport analysis.analysis_jet_feature as ajf\nimport util.experiment as ex\nimport POfAH.jet_sample as js\nimport util.event_sample as es\nimport util.plotting as up\nimport POfAH.util.sample_factory as sf\n\n\nrun_n = 101\ndata_sample = 'particle-local'\n\nexperiment = ex.Experiment(run_n).setup(fig_dir=True)\npaths = sf.SamplePathFactory(experiment, data_sample)\n\n\n# ********************************************************\n#       read in training data ( events )\n# ********************************************************\n\nqcd_sample = js.JetSample.from_input_file('qcdSide',paths.qcd_file_path)\nscikit_qcd_sample = ajf.dijet_sample_from_dijet_sample(qcd_sample)\nptjj = [j.pt for j in scikit_qcd_sample]\n\nup.plot_hist(ptjj, title='ptjj', plot_name='ptjj_dist', fig_dir=experiment.fig_dir, xlim=(-1,10), bins=3000)\n\n\n\n# scikit dijet sample from particle sample\nevent_sample = es.EventSample.from_input_file('GtoWW30br','../data/events/RSGraviton_WW_BROAD_13TeV_PU40_3.0TeV_concat_10K.h5')\nj1_particles, j2_particles = event_sample.get_particles()\nj1_scikit = ajf.jet_sample_from_particle_sample(j1_particles)\nj2_scikit = ajf.jet_sample_from_particle_sample(j2_particles)\njj_scikit = [j1+j2 for j1,j2 in zip(j1_scikit,j2_scikit)]\nmjj_scikit = [j.mass for j in jj_scikit]\nptjj_scikit = [j.pt for j in jj_scikit]\n\n# original dijet sample\njet_sample = js.JetSample.from_input_file('GtoWW30br','../data/events/RSGraviton_WW_BROAD_13TeV_PU40_3.0TeV_concat_10K.h5')\n#scikit dijet sample from original dijet sample\njet_sample_scikit = ajf.dijet_sample_from_dijet_sample(jet_sample)\nmjj_scikit_from_orig = [j.mass for j in jet_sample_scikit]\nptjj_scikit_from_orig = [j.pt for j in jet_sample_scikit]\n\nup.plot_hist(mjj_scikit,title='mjj scikit',plot_name='hist_mjj_scikit',fig_dir=experiment.fig_dir)\nup.plot_hist(jet_sample['mJJ'],title='mjj original',plot_name='hist_mjj_original',fig_dir=experiment.fig_dir)\nup.plot_hist(mjj_scikit_from_orig,title='mjj scikit from original',plot_name='hist_mjj_scikit_from_original',fig_dir=experiment.fig_dir)\n\nup.plot_hist(ptjj_scikit,title='ptjj scikit',plot_name='hist_ptjj_scikit',fig_dir=experiment.fig_dir)\nup.plot_hist(ptjj_scikit_from_orig,title='ptjj scikit from original',plot_name='hist_ptjj_scikit_from_original',fig_dir=experiment.fig_dir)\n\nexit()\n\n\n# select model\nexperiment = ex.Experiment(run_n=45)\n\n# read in original and reconstructed datasets\n\nsample_original_id = 'GtoWW35br'\njet_sample_original = js.JetSample.from_input_file(sample_original_id, os.path.join(sd.base_dir_events, sd.file_names[sample_original_id]+'_mjj_cut_concat_200K.h5'))\n\nsample_reco_id = 'GtoWW35brReco'\nevt_sample_reco = es.EventSample.from_input_file(sample_reco_id,os.path.join(experiment.result_dir, sd.file_names[sample_reco_id]+'.h5'))\nj1_reco_particles, j2_reco_particles = evt_sample_reco.get_particles()\n\n# compute jets from particles\nj1_reco = ajf.jet_sample_from_particle_sample(j1_reco_particles)\nj2_reco = ajf.jet_sample_from_particle_sample(j2_reco_particles)\njj_reco = [j1+j2 for j1,j2 in zip(j1_reco,j2_reco)]\n# get dijet mass and dijet pt\nm_jj_reco = [ event_jj.mass for event_jj in jj_reco]\npt_jj_reco = [ event_jj.pt for event_jj in jj_reco]\n\n# compute dijet pt for original data sample\njj_orig = ajf.dijet_sample_from_dijet_sample(jet_sample_original)\nm_jj_orig_scikit = [event.mass for event in jj_orig]\nm_jj_orig = jet_sample_original['mJJ']\npt_jj_orig_scikit = [event.pt for event in jj_orig]\n\nup.plot_hist([m_jj_orig,m_jj_orig_scikit,m_jj_reco],xlabel='mJJ',title='mJJ distribution',plot_name='hist_jet_feature_mjj',legend=['orig','orig scikit','reco'],fig_dir=experiment.fig_dir)\nup.plot_hist([pt_jj_orig_scikit,pt_jj_reco],xlabel='ptJJ',title='ptJJ distribution',plot_name='hist_jet_feature_ptjj',legend=['orig scikit','reco'],fig_dir=experiment.fig_dir)\n",
			"file": "main_analysis_jet_features.py",
			"file_size": 3835,
			"file_write_time": 132411175850000000,
			"settings":
			{
				"buffer_size": 3835,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import setGPU\n\nfrom vae.vae_model import VAE\nfrom vae.vae_highres_model import VAE_HR\nimport vae.losses as lo\nimport pofah.util.input_data_reader as idr\nimport pofah.util.sample_factory as sf\nimport pofah.jet_sample as js\nimport pofah.util.experiment as ex\n\n\n# ********************************************************\n#               runtime params\n# ********************************************************\n\nrun_n = 4\ndata_sample = 'img-local-54'\n\nexperiment = ex.Experiment(run_n).setup(result_dir=True)\npaths = sf.SamplePathFactory(experiment,data_sample)\n\n# ********************************************\n#               load model\n# ********************************************\n\nvae = VAE(run=run_n, model_dir=experiment.model_dir)\nvae.load()\n\n# ********************************************\n#               read test data (images)\n# ********************************************\n\n#sample_ids = ['qcdSide', 'qcdSig', 'GtoWW15na', 'GtoWW15br', 'GtoWW25na', 'GtoWW25br', 'GtoWW35na', 'GtoWW35br', 'GtoWW45na', 'GtoWW45br']\nsample_ids = ['GtoWW25br', 'GtoWW35na']\n\nfor sample_id in sample_ids:\n\n    data_reader = idr.InputDataReader(paths.sample_path(sample_id))\n    test_img_j1, test_img_j2 = data_reader.read_images( )\n\n\n    # *******************************************************\n    #               predict test data\n    # *******************************************************\n\n    print('-'*10, 'predicting', '-'*10)\n    reco_img_j1, z_mean_j1, z_log_var_j1 = vae.predict_with_latent( test_img_j1 )\n    reco_img_j2, z_mean_j2, z_log_var_j2 = vae.predict_with_latent( test_img_j2 )\n\n    # *******************************************************\n    #               compute losses\n    # *******************************************************\n\n    print('-'*10, 'computing losses', '-'*10)\n    losses_j1 = lo.compute_loss_of_prediction_mse_kl(test_img_j1, reco_img_j1, z_mean_j1, z_log_var_j1, input_size=54)\n    losses_j2 = lo.compute_loss_of_prediction_mse_kl(test_img_j2, reco_img_j2, z_mean_j2, z_log_var_j2, input_size=54)\n\n    # *******************************************************\n    #               add losses to DataSample and save\n    # *******************************************************\n\n    predicted_sample = js.JetSample.from_feature_array(sample_id, *data_reader.read_dijet_features())\n    \n    for loss, label in zip( losses_j1, ['j1TotalLoss', 'j1RecoLoss', 'j1KlLoss']):\n        predicted_sample.add_feature(label,loss)\n    for loss, label in zip( losses_j2, ['j2TotalLoss', 'j2RecoLoss', 'j2KlLoss']):\n        predicted_sample.add_feature(label,loss)\n\n    predicted_sample.dump(paths.result_path(sample_id + 'Reco'))\n\n",
			"file": "main_predict.py",
			"file_size": 2651,
			"file_write_time": 132411920700000000,
			"settings":
			{
				"buffer_size": 2651,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import os\nimport matplotlib.pyplot as plt\nimport pathlib\n\nimport tensorflow as tf\n\nimport config.config as co\nfrom vae.losses import *\n\n\n# sampling layer\nclass Sampling(tf.keras.layers.Layer):\n    \"\"\"\n    instead of sampling from Q(z|X),\n    sample eps = N(0,I), then z = z_mean + sqrt(var)*eps\n\n    # Arguments:\n        args (tensor): mean and log of variance of Q(z|X)\n\n    # Returns:\n        z (tensor): sampled latent vector\n    \"\"\"\n    def call(self, args):\n        z_mean, z_log_var = args\n        batch = tf.shape(z_mean)[0]\n        dim = tf.shape(z_mean)[1]\n        epsilon = tf.keras.backend.random_normal(shape=(batch, dim))\n        # by default, random_normal has mean=0 and std=1.0\n        return z_mean + tf.exp(0.5 * z_log_var) * epsilon\n\n\nclass VAE( object ):\n\n    def __init__(self, run=0, log_dir=co.config['tensorboard_dir'], model_dir=co.config['model_dir'], input_size=32, z_size=10, filter_n=6):\n        # network parameters\n        self.input_shape = (input_size, input_size)\n        self.batch_size = 128\n        self.kernel_size = 3\n        self.filter_n = filter_n\n        self.z_size = z_size\n        self.run = run\n        self.log_dir = log_dir\n        self.model_dir = model_dir\n        self.regularizer = None # regularizers.l2()\n\n    # adding keras mse as dummy loss and dummy kl_loss_fun, because training loss in function closure not (easily) accessible and model won't load without all custom function references\n    def load( self ):\n        self.encoder = tf.keras.models.load_model(os.path.join(self.model_dir, 'encoder.h5'), custom_objects={'mse_kl_loss': mse_kl_loss, 'mse_loss_fun': tf.keras.losses.mse, 'kl_loss_for_metric': kl_loss_for_metric, 'Sampling' : Sampling})\n        self.decoder = tf.keras.models.load_model(os.path.join(self.model_dir, 'decoder.h5'), custom_objects={'mse_kl_loss': mse_kl_loss, 'mse_loss_fun': tf.keras.losses.mse, 'kl_loss_for_metric': kl_loss_for_metric})\n        self.model = tf.keras.models.load_model(os.path.join(self.model_dir, 'vae.h5'), custom_objects={'mse_kl_loss': mse_kl_loss, 'mse_loss_fun': tf.keras.losses.mse, 'kl_loss_for_metric': kl_loss_for_metric, 'loss': tf.keras.losses.mse, 'kl_loss_fun': kl_loss, 'Sampling' : Sampling})\n\n\n    def build( self ):\n\n        inputs = tf.keras.layers.Input(shape=self.input_shape, dtype=tf.float32, name='encoder_input')\n        self.encoder = self.build_encoder(inputs)\n        self.decoder = self.build_decoder( )\n        outputs = self.decoder( self.z )  # link encoder output to decoder\n        # instantiate VAE model\n        vae = tf.keras.Model(inputs, outputs, name='vae')\n        vae.summary()\n        self.compile( vae )\n        self.model = vae\n\n\n    def compile(self, model):\n        model.compile(optimizer='adam', loss=mse_kl_loss(self.z_mean, self.z_log_var, self.input_shape[0]), metrics=[mse_loss(self.input_shape[0]), kl_loss_for_metric(self.z_mean,self.z_log_var)], experimental_run_tf_function=False)  # , metrics=loss_metrics monitor mse and kl terms of loss 'rmsprop'\n\n    # ***********************************\n    #               encoder\n    # ***********************************\n    def build_encoder(self, inputs):\n\n        x = tf.keras.layers.Dropout(0.5)(inputs)\n\n        x = tf.keras.layers.Lambda(lambda x: tf.expand_dims(x, axis=3))(x) # [B x N_pix x N_pix] => [B x N_pix x N_pix x 1]\n\n        for i in range(3):\n            x = tf.keras.layers.Conv2D(filters=self.filter_n, kernel_size=self.kernel_size, activation='relu', kernel_regularizer=self.regularizer)(x)\n            self.filter_n += 4\n\n        x = tf.keras.layers.AveragePooling2D()(x)\n        # x = MaxPooling2D( )( x )\n\n        # shape info needed to build decoder model\n        self.shape_convolved = x.get_shape().as_list()\n\n        # 3 dense layers\n        x = tf.keras.layers.Flatten()(x)\n        self.size_convolved = x.get_shape().as_list()\n        x = tf.keras.layers.Dense(self.size_convolved[1] // 17, activation='relu',kernel_regularizer=self.regularizer)(x)  # reduce convolution output\n        x = tf.keras.layers.Dense(self.size_convolved[1] // 42, activation='relu',kernel_regularizer=self.regularizer)(x)  # reduce again\n        #x = Dense(8, activation='relu')(x)\n\n        # *****************************\n        #         latent space\n        # generate latent vector Q(z|X)\n\n        self.z_mean = tf.keras.layers.Dense(self.z_size, name='z_mean', kernel_regularizer=self.regularizer)(x)\n        self.z_log_var = tf.keras.layers.Dense(self.z_size, name='z_log_var', kernel_regularizer=self.regularizer)(x)\n\n        # use reparameterization trick to push the sampling out as input\n        self.z = Sampling()((self.z_mean, self.z_log_var))\n\n        # instantiate encoder model\n        encoder = tf.keras.Model(inputs, [self.z_mean, self.z_log_var, self.z], name='encoder')\n        encoder.summary()\n        # plot_model(encoder, to_file=CONFIG['plotdir']+'vae_cnn_encoder.png', show_shapes=True)\n        return encoder\n\n\n    # ***********************************\n    #           decoder\n    # ***********************************\n    def build_decoder(self):\n\n        latent_inputs = tf.keras.layers.Input(shape=(self.z_size,), name='z_sampling')\n        x = tf.keras.layers.Dense(self.size_convolved[1] // 42, activation='relu',kernel_regularizer=self.regularizer)(latent_inputs)  # inflate to input-shape/200\n        x = tf.keras.layers.Dense(self.size_convolved[1] // 17, activation='relu',kernel_regularizer=self.regularizer)(x)  # double size\n        x = tf.keras.layers.Dense(self.shape_convolved[1] * self.shape_convolved[2] * self.shape_convolved[3], activation='relu',kernel_regularizer=self.regularizer)(x)\n        x = tf.keras.layers.Reshape((self.shape_convolved[1], self.shape_convolved[2], self.shape_convolved[3]))(x)\n\n        x = tf.keras.layers.UpSampling2D()(x)\n\n        for i in range(3):\n            self.filter_n -= 4\n            x = tf.keras.layers.Conv2DTranspose(filters=self.filter_n, kernel_size=self.kernel_size, activation='relu',kernel_regularizer=self.regularizer)(x)\n\n        x = tf.keras.layers.Dropout(0.5)(x)\n\n        x = tf.keras.layers.Conv2DTranspose(filters=1, kernel_size=self.kernel_size, activation='relu', kernel_regularizer=self.regularizer, padding='same', name='decoder_output')(x)\n        outputs_decoder = tf.keras.layers.Lambda(lambda x: tf.squeeze(x, axis=3))(x) # [B x N_pix x N_pix x 1] -> [B x N_pix x N_pix]\n\n\n        # instantiate decoder model\n        decoder = tf.keras.Model(latent_inputs, outputs_decoder, name='decoder')\n        decoder.summary()\n        # plot_model(decoder, to_file=CONFIG['plotdir'] + 'vae_cnn_decoder.png', show_shapes=True)\n        return decoder\n\n\n    def fit( self, x, y, epochs=3, verbose=2 ):\n        callbacks = [tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=7, verbose=1),tf.keras.callbacks.ReduceLROnPlateau(monitor='val_loss', factor=0.1, patience=2, verbose=1),tf.keras.callbacks.TerminateOnNaN(),\n                     ] #TensorBoard(log_dir=self.log_dir, histogram_freq=1)\n        self.history = self.model.fit(x, y, batch_size=self.batch_size, epochs=epochs, verbose=verbose, callbacks=callbacks, validation_split=0.25)\n        return self.history\n\n\n    def predict(self, x):\n        return self.model.predict( x, batch_size=self.batch_size )\n\n\n    def predict_with_latent(self,x):\n        z_mean, z_log_var, z = self.encoder.predict(x, batch_size=self.batch_size)\n        reco = self.decoder.predict(z, batch_size=self.batch_size)\n        return [ reco, z_mean, z_log_var ]\n\n\n    def save_model(self):\n        print('saving model to {}'.format(self.model_dir))\n        self.encoder.save(os.path.join(self.model_dir, 'encoder.h5'))\n        self.decoder.save(os.path.join(self.model_dir,'decoder.h5'))\n        self.model.save(os.path.join(self.model_dir,'vae.h5'))\n\n\n    def plot_training(self, fig_dir=co.config['fig_dir'] ):\n        plt.figure()\n        plt.semilogy(self.history.history['loss'])\n        plt.semilogy(self.history.history['val_loss'])\n        plt.title('training and validation loss')\n        plt.ylabel('loss')\n        plt.xlabel('epoch')\n        plt.legend(['training','validation'], loc='upper right')\n        plt.savefig(os.path.join(fig_dir,'loss.png'))\n        plt.close()\n\n    def sample_pixels_from_dist(self,dist):\n        return np.random.exponential(1. / dist)  # numpy exponential dist takes 1/k param instead of k param\n",
			"file": "vae/vae_model.py",
			"file_size": 8390,
			"file_write_time": 132410227780000000,
			"settings":
			{
				"buffer_size": 8390,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "from collections import OrderedDict\nimport os\n\nimport analysis_main.main_analysis_losses as al\nimport analysis.analysis_roc as ar\nimport pofah.util.experiment as ex\nimport pofah.jet_sample as js\nimport pofah.sample_dict as sd\nimport pofah.util.sample_factory as sf\nimport discriminator.loss_strategy as ls\n\n\n# ********************************************************\n#               runtime params\n# ********************************************************\n\nrun_n_model1 = 46\nrun_n_model2 = 49\n\nSM_sample = 'qcdSideReco'\nBSM_samples = ['GtoWW15naReco', 'GtoWW15brReco', 'GtoWW25naReco', 'GtoWW25brReco','GtoWW35naReco', 'GtoWW35brReco', 'GtoWW45naReco', 'GtoWW45brReco']\nstrategies = ['s1', 's2', 's3', 's4', 's5', 'k1', 'k2']\n\nall_sample_ids = [SM_sample] + BSM_samples\nmass_centers = [1500, 1500, 2500, 2500, 3500, 3500, 4500, 4500]\n\n# read JET IMAGE VAE model results\nexperiment = ex.Experiment(run_n_model1)\ndata_img_vae = sf.read_results_to_jet_sample_dict(all_sample_ids, experiment, mode='img-local')\n\n# read 3D LOSS VAE model results\nexperiment = ex.Experiment(run_n_model2).setup(fig_dir=True)\ndata_3d_vae = sf.read_results_to_jet_sample_dict(all_sample_ids, experiment, mode='img-local')\n\nfor s in strategies:\n\n    strategy = ls.loss_strategies[s]\n\n    for BSM_sample, mass_center in zip(BSM_samples, mass_centers):\n        _, binned_bg_img_vae, _  = ar.get_mjj_binned_sample(data_img_vae[SM_sample], mass_center)\n        _, binned_sig_img_vae, _ = ar.get_mjj_binned_sample(data_img_vae[BSM_sample], mass_center)\n        _, binned_bg_3D_vae, _ = ar.get_mjj_binned_sample(data_3d_vae[SM_sample], mass_center)\n        _, binned_sig_3D_vae, _ = ar.get_mjj_binned_sample(data_3d_vae[BSM_sample], mass_center)\n\n        neg_class_losses = [strategy(b) for b in [binned_bg_img_vae, binned_bg_3D_vae]]\n        pos_class_losses = [strategy(s) for s in [binned_sig_img_vae, binned_sig_3D_vae]]\n        legend = [binned_sig_img_vae.name + ' model ' + str(run_n_model1), binned_sig_img_vae.name + ' model ' + str(run_n_model2) ]\n\n        ar.plot_roc(neg_class_losses, pos_class_losses, legend=legend, title='model comparison ROC binned strategy ' + strategy.title_str + ' ' + sd.sample_name[BSM_sample], log_x=True, plot_name='ROC_binned_logTPR_' + strategy.file_str + '_' + sd.file_names[BSM_sample], fig_dir='fig/run_'+str(run_n_model1)+'_vs_'+str(run_n_model2), xlim=10**(-3))\n\n\n\n\n\n",
			"file": "main_analysis_model_comparison.py",
			"file_size": 2383,
			"file_write_time": 132411175850000000,
			"settings":
			{
				"buffer_size": 2383,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import analysis.analysis_bg_vs_sig as bgsig\nimport discriminator.loss_strategy as ls\nimport util.plotting as up\nimport pofah.sample_dict as sd\n\n\nlosses = ['j1TotalLoss','j2TotalLoss','j1RecoLoss','j2RecoLoss','j1KlLoss','j2KlLoss']\nstrategies = ['s1', 's2', 's3', 's4', 's5']\n\ndef analyze_losses(experiment, sample_dict, samples_to_analyze, plot_suffix=''):\n    for loss in losses:\n        bgsig.plot_feature(sample_dict, loss, samples_to_analyze, fig_dir=experiment.fig_dir_event, plot_suffix=plot_suffix)\n\n\ndef analyze_loss_strategies(experiment, sample_dict, samples_to_analyze, plot_suffix=''):\n    legend = [ sample_dict[samp].name for samp in samples_to_analyze ]\n    for strategy in ls.loss_strategies.values():\n        combined_loss = [ strategy(sample_dict[samp]) for samp in samples_to_analyze]\n        bgsig.plot_bg_vs_sig_distribution(combined_loss,xlabel=strategy.title_str,title=strategy.title_str+' distribution',fig_dir=experiment.fig_dir_event,plot_name='hist_'+strategy.file_str+'_'+plot_suffix,legend=legend)\n\n\ndef analyze_loss_strategies_keep_for_roc(experiment, sample_dict, samples_to_analyze, plot_suffix=''):\n    legend = [ ls.loss_strategies[s].title_str for s in strategies]\n    for sample in samples_to_analyze:\n        title_suffix = sd.sample_name[sample]\n        file_suffix = sd.file_names[sample]\n        combined_losses = [strategy(sample_dict[sample]) for strategy in ls.loss_strategies.values()]\n        up.plot_hist(combined_losses,xlabel='combined loss',legend=legend,title='combined loss strategies '+title_suffix,plot_name='hist_loss_strategies_'+plot_suffix+'_'+file_suffix,fig_dir=experiment.fig_dir_event)\n",
			"file": "analysis/analysis_losses.py",
			"file_size": 1648,
			"file_write_time": 132411175840000000,
			"settings":
			{
				"buffer_size": 1648,
				"line_ending": "Unix"
			}
		},
		{
			"file": "analysis/analysis_constituents.py",
			"settings":
			{
				"buffer_size": 958,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import os\nfrom collections import OrderedDict\n\nimport analysis.analysis_losses as alo\nimport pofah.jet_sample as js\nimport pofah.util.experiment as ex\nimport pofah.sample_dict as sd\nimport pofah.util.sample_factory as sf\n\ndef analyze_losses( run_n, SM_sample_id, BSM_sample_ids, plot_suffix=''):\n\n    experiment = ex.Experiment(run_n=run_n).setup(fig_dir=True)\n    paths = sf.SamplePathFactory(experiment)  # 'default' datasample because reading only results\n\n    all_samples = [SM_sample_id] + BSM_sample_ids\n\n    data = OrderedDict()\n    for sample_id in all_samples:\n        data[sample_id] = js.JetSample.from_input_file(sample_id, paths.result_path(sample_id))\n\n    alo.analyze_losses(experiment, data, all_samples, plot_suffix)\n\n    alo.analyze_loss_strategies(experiment, data, all_samples, plot_suffix)",
			"file": "analysis_main/main_analysis_losses.py",
			"file_size": 810,
			"file_write_time": 132411175850000000,
			"settings":
			{
				"buffer_size": 810,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "from collections import OrderedDict\nimport os\n\nimport analysis.analysis_roc as ar\nimport discriminator.loss_strategy as ls\nimport pofah.sample_dict as sd\nimport pofah.jet_sample as js\nimport pofah.util.experiment as ex\n\n\nstrategies = ['s1', 's2', 's3', 's4', 's5']\n\nlegend = [ls.loss_strategies[s].title_str for s in strategies]\n\nrun_n = 45\nexperiment = ex.Experiment(run_n).setup(fig_dir=True)\n\nSM_sample = 'qcdSideReco'\nBSM_samples = ['qcdSigReco', 'GtoWW15naReco', 'GtoWW15brReco', 'GtoWW25naReco', 'GtoWW25brReco','GtoWW35naReco', 'GtoWW35brReco', 'GtoWW45naReco', 'GtoWW45brReco']\n\nall_samples = [SM_sample] + BSM_samples\n\n\ndata = OrderedDict()\nfor sample_id in all_samples:\n    data[sample_id] = js.JetSample.from_input_file(sample_id, os.path.join(experiment.result_dir, sd.file_names[sample_id]+'.h5'))\n\n# plot standard ROC for all strategies\nfor BSM_sample in BSM_samples:\n\n    neg_class_losses = [strategy( data[SM_sample] ) for strategy in ls.loss_strategies.values()]\n    pos_class_losses = [strategy( data[BSM_sample] ) for strategy in ls.loss_strategies.values()]\n\n    ar.plot_roc( neg_class_losses, pos_class_losses, legend=legend, title='ROC '+sd.sample_name[BSM_sample], plot_name='ROC_'+sd.file_names[BSM_sample], fig_dir=experiment.fig_dir_event )\n\n# plot binned ROC\nBSM_samples = ['GtoWW15brReco','GtoWW15naReco','GtoWW25brReco','GtoWW25naReco','GtoWW35brReco','GtoWW35naReco','GtoWW45brReco','GtoWW45naReco']\nmass_centers = [1500,1500,2500,2500,3500,3500,4500,4500]\nstrategies = ['s3','s4','s5']\n\nfor s in strategies:\n\n    strategy = ls.loss_strategies[s]\n\n    for BSM_sample, mass_center in zip(BSM_samples,mass_centers):\n\n        binned_bg = ar.get_mjj_binned_sample(data[SM_sample], mass_center)\n        binned_sig = ar.get_mjj_binned_sample(data[BSM_sample], mass_center)\n\n        neg_class_losses = [ strategy( b ) for b in binned_bg ]\n        pos_class_losses = [ strategy( s ) for s in binned_sig ]\n        legend = [ s.name for s in binned_sig ]\n\n        ar.plot_roc(neg_class_losses, pos_class_losses, legend=legend, title='ROC binned strategy '+ strategy.title_str+' '+ sd.sample_name[BSM_sample], plot_name='ROC_binned_'+strategy.file_str+'_'+ sd.file_names[BSM_sample], fig_dir=experiment.fig_dir_event)\n\n",
			"file": "analysis_main/main_analysis_roc.py",
			"file_size": 2238,
			"file_write_time": 132411175850000000,
			"settings":
			{
				"buffer_size": 2238,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import os\n#import setGPU\nimport numpy as np\n\nimport POfAH.util.experiment as ex\nimport POfAH.util.input_data_reader as idr\nfrom vae.vae_3Dloss_model import VAE_3D\nimport POfAH.sample_dict as sd\nimport config.config as co\nimport POfAH.util.sample_factory as sf\nimport util.utility_fun as ut\n\nimport sys\nprint('Python: ', sys.version)\nimport tensorflow as tf\nprint('Tensorflow: ', tf.__version__)\n\n# ********************************************************\n#       runtime params\n# ********************************************************\n\nrun_n = 101\ndata_sample = 'particle'\n\nexperiment = ex.Experiment(run_n).setup(model_dir=True, fig_dir=True)\npaths = sf.SamplePathFactory(experiment, data_sample)\n\n\n# ********************************************************\n#       read in training data ( events )\n# ********************************************************\n\ndata_reader = idr.InputDataReader(paths.qcd_path)\ntrain_evts_j1, train_evts_j2 = data_reader.read_jet_constituents(with_names=False)\n\n# ********************************************************\n#       prepare training data\n# ********************************************************\n\ntraining_evts = np.vstack([train_evts_j1, train_evts_j2])\nnp.random.shuffle(training_evts)\nmean, std_dev = ut.get_mean_and_std(training_evts)\n\n# *******************************************************\n#                       build model\n# *******************************************************\n\nvae = VAE_3D(run=run_n, model_dir=experiment.model_dir)\nvae.build(mean, std_dev)\n\n# *******************************************************\n#                       train and save\n# *******************************************************\n\nhistory = vae.fit(training_evts, training_evts, epochs=100, verbose=2)\nvae.plot_training(experiment.fig_dir)\nvae.save_model()",
			"file": "main_train_3d_vae.py",
			"file_size": 1804,
			"file_write_time": 132411175850000000,
			"settings":
			{
				"buffer_size": 1804,
				"line_ending": "Unix"
			}
		},
		{
			"file": "main_predict_3d_vae.py",
			"settings":
			{
				"buffer_size": 3613,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import tensorflow as tf\nimport numpy as np\n\nimport pofah.util.event_sample as es\n\n\ndef extract_events(file_path):\n\ttest_sample = es.EventSample.from_input_file('qcdSig', file_path.numpy().decode('utf-8'))\n\ttest_evts_j1, test_evts_j2 = test_sample.get_particles()\n\tprint('{}: {} j1 evts, {} j2 evts'.format(test_sample.name, len(test_evts_j1), len(test_evts_j2)))\n\treturn [test_evts_j1, test_evts_j2]\n\n\nroot_dir = '/eos/home-k/kiwoznia/dev/autoencoder_for_anomaly/convolutional_VAE/data/events/qcd_sqrtshatTeV_13TeV_PU40_parts'\n\nlist_ds = tf.data.Dataset.list_files(root_dir+'/*')\n\n#list_samples = list_ds.map(extract_events)\n#print(list_samples)\n\nfor file_path in list_ds:\n\ttest_sample = es.EventSample.from_input_file('qcdSig', file_path.numpy().decode('utf-8'))\n\ttest_evts_j1, test_evts_j2 = test_sample.get_particles()\n\tprint('{}: {} j1 evts, {} j2 evts'.format(test_sample.name, len(test_evts_j1), len(test_evts_j2)))\n\n\nfilelist = ['fileA_6', 'fileB_10', 'fileC_7']\n\ndef map_element_counts(fnames):\n  return {'elementA': b'test', 'elementB': 10, 'file': fnames['filenames']}\n\nds = tf.data.Dataset.from_tensor_slices({'filenames': filelist})\nds = ds.map(map_func=map_element_counts)\n#element = ds.make_one_shot_iterator().get_next()\n\nfor dat in ds:\n\tprint(dat)\n",
			"file": "playground/test_tf_dataset.py",
			"file_size": 1264,
			"file_write_time": 132428334920000000,
			"settings":
			{
				"buffer_size": 1264,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "import tensorflow as tf\n\n@tf.function\ndef bar(vv):\n\tprint(vv)\n\treturn vv\n\t\n\ndef foo(v):\n\tfor vv in v:\n\t\tprint(vv.numpy())\n\nv = tf.random.uniform([4, 10], minval=1, maxval=10, dtype=tf.int32)\ndataset = tf.data.Dataset.from_tensor_slices(v)\ndataset.map(bar)\nfoo(dataset)\n",
			"file": "playground/tf_test.py",
			"file_size": 269,
			"file_write_time": 132427501850000000,
			"settings":
			{
				"buffer_size": 269,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Python wrappers for Datasets.\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport abc\nimport functools\nimport sys\nimport threading\nimport warnings\nimport weakref\n\nimport numpy as np\nimport six\nfrom six.moves import queue as Queue  # pylint: disable=redefined-builtin\n\nfrom tensorflow.core.framework import graph_pb2\nfrom tensorflow.python import tf2\nfrom tensorflow.python.compat import compat\nfrom tensorflow.python.data.experimental.ops import distribute_options\nfrom tensorflow.python.data.experimental.ops import optimization_options\nfrom tensorflow.python.data.experimental.ops import stats_options\nfrom tensorflow.python.data.experimental.ops import threading_options\nfrom tensorflow.python.data.ops import iterator_ops\nfrom tensorflow.python.data.util import nest\nfrom tensorflow.python.data.util import options as options_lib\nfrom tensorflow.python.data.util import random_seed\nfrom tensorflow.python.data.util import structure\nfrom tensorflow.python.data.util import traverse\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import function as eager_function\nfrom tensorflow.python.framework import auto_control_deps\nfrom tensorflow.python.framework import auto_control_deps_utils as acd_utils\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import function\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import random_seed as core_random_seed\nfrom tensorflow.python.framework import smart_cond\nfrom tensorflow.python.framework import sparse_tensor as sparse_tensor_lib\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.framework import tensor_util\nfrom tensorflow.python.framework import type_spec\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import gen_dataset_ops\nfrom tensorflow.python.ops import gen_experimental_dataset_ops as ged_ops\nfrom tensorflow.python.ops import gen_io_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import script_ops\nfrom tensorflow.python.ops import string_ops\nfrom tensorflow.python.training.tracking import base as tracking_base\nfrom tensorflow.python.training.tracking import tracking\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util import function_utils\nfrom tensorflow.python.util import lazy_loader\nfrom tensorflow.python.util import nest as tf_nest\nfrom tensorflow.python.util.tf_export import tf_export\n\n# Loaded lazily due to a circular dependency (roughly\n# tf.function->wrap_function->dataset->autograph->tf.function).\n# TODO(b/133251390): Use a regular import.\nwrap_function = lazy_loader.LazyLoader(\n    \"wrap_function\", globals(),\n    \"tensorflow.python.eager.wrap_function\")\n# TODO(mdan): Create a public API for this.\nautograph_ctx = lazy_loader.LazyLoader(\n    \"autograph_ctx\", globals(),\n    \"tensorflow.python.autograph.core.ag_ctx\")\nautograph = lazy_loader.LazyLoader(\n    \"autograph\", globals(),\n    \"tensorflow.python.autograph.impl.api\")\n\nops.NotDifferentiable(\"ReduceDataset\")\n\n# A constant that can be used to enable auto-tuning.\nAUTOTUNE = -1\ntf_export(\"data.experimental.AUTOTUNE\").export_constant(__name__, \"AUTOTUNE\")\n\n\n@tf_export(\"data.Dataset\", v1=[])\n@six.add_metaclass(abc.ABCMeta)\nclass DatasetV2(tracking_base.Trackable, composite_tensor.CompositeTensor):\n  \"\"\"Represents a potentially large set of elements.\n\n  The `tf.data.Dataset` API supports writing descriptive and efficient input\n  pipelines. `Dataset` usage follows a common pattern:\n\n  1. Create a source dataset from your input data.\n  2. Apply dataset transformations to preprocess the data.\n  3. Iterate over the dataset and process the elements.\n\n  Iteration happens in a streaming fashion, so the full dataset does not need to\n  fit into memory.\n\n  Source Datasets:\n\n  The simplest way to create a dataset is to create it from a python `list`:\n\n  >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n  >>> for element in dataset:\n  ...   print(element)\n  tf.Tensor(1, shape=(), dtype=int32)\n  tf.Tensor(2, shape=(), dtype=int32)\n  tf.Tensor(3, shape=(), dtype=int32)\n\n  To process lines from files, use `tf.data.TextLineDataset`:\n\n  >>> dataset = tf.data.TextLineDataset([\"file1.txt\", \"file2.txt\"])\n\n  To process records written in the `TFRecord` format, use `TFRecordDataset`:\n\n  >>> dataset = tf.data.TFRecordDataset([\"file1.tfrecords\", \"file2.tfrecords\"])\n\n  To create a dataset of all files matching a pattern, use\n  `tf.data.Dataset.list_files`:\n\n  >>> dataset = tf.data.Dataset.list_files(\"/path/*.txt\")  # doctest: +SKIP\n\n  See `tf.data.FixedLengthRecordDataset` and `tf.data.Dataset.from_generator`\n  for more ways to create datasets.\n\n  Transformations:\n\n  Once you have a dataset, you can apply transformations to prepare the data for\n  your model:\n\n  >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n  >>> dataset = dataset.map(lambda x: x*2)\n  >>> list(dataset.as_numpy_iterator())\n  [2, 4, 6]\n\n  Common Terms:\n\n  **Element**: A single output from calling `next()` on a dataset iterator.\n    Elements may be nested structures containing multiple components. For\n    example, the element `(1, (3, \"apple\"))` has one tuple nested in another\n    tuple. The components are `1`, `3`, and `\"apple\"`.\n  **Component**: The leaf in the nested structure of an element.\n\n  Supported types:\n\n  Elements can be nested structures of tuples, named tuples, and dictionaries.\n  Element components can be of any type representable by `tf.TypeSpec`,\n  including `tf.Tensor`, `tf.data.Dataset`, `tf.SparseTensor`,\n  `tf.RaggedTensor`, and `tf.TensorArray`.\n\n  >>> a = 1 # Integer element\n  >>> b = 2.0 # Float element\n  >>> c = (1, 2) # Tuple element with 2 components\n  >>> d = {\"a\": (2, 2), \"b\": 3} # Dict element with 3 components\n  >>> Point = collections.namedtuple(\"Point\", [\"x\", \"y\"]) # doctest: +SKIP\n  >>> e = Point(1, 2) # Named tuple # doctest: +SKIP\n  >>> f = tf.data.Dataset.range(10) # Dataset element\n\n  \"\"\"\n\n  def __init__(self, variant_tensor):\n    \"\"\"Creates a DatasetV2 object.\n\n    This is a difference between DatasetV1 and DatasetV2. DatasetV1 does not\n    take anything in its constructor whereas in the DatasetV2, we expect\n    subclasses to create a variant_tensor and pass it in to the super() call.\n\n    Args:\n      variant_tensor: A DT_VARIANT tensor that represents the dataset.\n    \"\"\"\n    self._variant_tensor_attr = variant_tensor\n    weak_self = weakref.proxy(self)\n    self._variant_tracker = self._track_trackable(\n        _VariantTracker(\n            self._variant_tensor,\n            # _trace_variant_creation only works when executing eagerly, so we\n            # don't want to run it immediately. We also want the _VariantTracker\n            # to have a weak reference to the Dataset to avoid creating\n            # reference cycles and making work for the garbage collector.\n            lambda: weak_self._trace_variant_creation()()),  # pylint: disable=unnecessary-lambda,protected-access\n        name=\"_variant_tracker\")\n    self._graph_attr = ops.get_default_graph()\n\n  @property\n  def _variant_tensor(self):\n    return self._variant_tensor_attr\n\n  @_variant_tensor.setter\n  def _variant_tensor(self, _):\n    raise ValueError(\"The _variant_tensor property is read-only\")\n\n  @deprecation.deprecated_args(None, \"Use external_state_policy instead\",\n                               \"allow_stateful\")\n  def _as_serialized_graph(\n      self,\n      allow_stateful=None,\n      strip_device_assignment=None,\n      external_state_policy=distribute_options.ExternalStatePolicy.WARN):\n    \"\"\"Produces serialized graph representation of the dataset.\n\n    Args:\n      allow_stateful: If true, we allow stateful ops to be present in the graph\n        def. In that case, the state in these ops would be thrown away.\n      strip_device_assignment: If true, non-local (i.e. job and task) device\n        assignment is stripped from ops in the serialized graph.\n      external_state_policy: The ExternalStatePolicy enum that determines how we\n        handle input pipelines that depend on external state. By default, its\n        set to WARN.\n\n    Returns:\n      A scalar `tf.Tensor` of `tf.string` type, representing this dataset as a\n      serialized graph.\n    \"\"\"\n    if external_state_policy:\n      policy = None\n      if external_state_policy:\n        policy = external_state_policy.value\n      return gen_dataset_ops.dataset_to_graph_v2(\n          self._variant_tensor,\n          external_state_policy=policy,\n          strip_device_assignment=strip_device_assignment)\n    if strip_device_assignment:\n      return gen_dataset_ops.dataset_to_graph(\n          self._variant_tensor,\n          allow_stateful=allow_stateful,\n          strip_device_assignment=strip_device_assignment)\n    return gen_dataset_ops.dataset_to_graph(\n        self._variant_tensor, allow_stateful=allow_stateful)\n\n  def _trace_variant_creation(self):\n    \"\"\"Traces a function which outputs a variant `tf.Tensor` for this dataset.\n\n    Note that creating this function involves evaluating an op, and is currently\n    only supported when executing eagerly.\n\n    Returns:\n      A zero-argument `ConcreteFunction` which outputs a variant `tf.Tensor`.\n    \"\"\"\n    variant = self._variant_tensor\n    if not isinstance(variant, ops.EagerTensor):\n      raise NotImplementedError(\n          \"Can only export Datasets which were created executing eagerly. \"\n          \"Please file a feature request if this is important to you.\")\n    with context.eager_mode(), ops.device(\"CPU\"):\n      # pylint: disable=protected-access\n      graph_def = graph_pb2.GraphDef().FromString(\n          self._as_serialized_graph(external_state_policy=distribute_options\n                                    .ExternalStatePolicy.FAIL).numpy())\n    output_node_name = None\n    for node in graph_def.node:\n      if node.op == \"_Retval\":\n        if output_node_name is not None:\n          raise AssertionError(\n              \"Found multiple return values from the dataset's graph, expected \"\n              \"only one.\")\n        output_node_name, = node.input\n    if output_node_name is None:\n      raise AssertionError(\"Could not find the dataset's output node.\")\n    # Add functions used in this Dataset to the function's graph, since they\n    # need to follow it around (and for example be added to a SavedModel which\n    # references the dataset).\n    variant_function = wrap_function.function_from_graph_def(\n        graph_def, inputs=[], outputs=output_node_name + \":0\")\n    for used_function in self._functions():\n      used_function.function.add_to_graph(variant_function.graph)\n    return variant_function\n\n  @abc.abstractmethod\n  def _inputs(self):\n    \"\"\"Returns a list of the input datasets of the dataset.\"\"\"\n\n    raise NotImplementedError(\"Dataset._inputs\")\n\n  @property\n  def _graph(self):\n    return self._graph_attr\n\n  @_graph.setter\n  def _graph(self, _):\n    raise ValueError(\"The _graph property is read-only\")\n\n  def _has_captured_ref(self):\n    \"\"\"Whether this dataset uses a function that captures ref variables.\n\n    Returns:\n      A boolean, which if true indicates that the dataset or one of its inputs\n      uses a function that captures ref variables.\n    \"\"\"\n    if context.executing_eagerly():\n      # RefVariables are not supported in eager mode\n      return False\n\n    def is_tensor_or_parent_ref(tensor):\n      if tensor.dtype._is_ref_dtype:  # pylint: disable=protected-access\n        return True\n      # If the captured tensor is an eager tensor, we cannot trace its inputs.\n      if isinstance(tensor, ops._EagerTensorBase):  # pylint: disable=protected-access\n        return False\n      return any(is_tensor_or_parent_ref(x) for x in tensor.op.inputs)\n\n    for fn in self._functions():\n      if any(is_tensor_or_parent_ref(t) for t in fn.function.captured_inputs):\n        return True\n\n    return any(\n        [input_dataset._has_captured_ref() for input_dataset in self._inputs()])  # pylint: disable=protected-access\n\n  # TODO(jsimsa): Change this to be the transitive closure of functions used\n  # by this dataset and its inputs.\n  def _functions(self):\n    \"\"\"Returns a list of functions associated with this dataset.\n\n    Returns:\n      A list of `StructuredFunctionWrapper` objects.\n    \"\"\"\n    return []\n\n  def options(self):\n    \"\"\"Returns the options for this dataset and its inputs.\n\n    Returns:\n      A `tf.data.Options` object representing the dataset options.\n    \"\"\"\n    options = Options()\n    for input_dataset in self._inputs():\n      input_options = input_dataset.options()\n      if input_options is not None:\n        options = options.merge(input_options)\n    return options\n\n  def _apply_options(self):\n    \"\"\"Apply options, such as optimization configuration, to the dataset.\"\"\"\n\n    dataset = self\n    options = self.options()\n\n    # (1) Apply threading options\n    if options.experimental_threading is not None:\n      t_options = options.experimental_threading\n      if t_options.max_intra_op_parallelism is not None:\n        dataset = _MaxIntraOpParallelismDataset(\n            dataset, t_options.max_intra_op_parallelism)\n      if t_options.private_threadpool_size is not None:\n        dataset = _PrivateThreadPoolDataset(dataset,\n                                            t_options.private_threadpool_size)\n\n    # (2) Apply graph rewrite options\n    # pylint: disable=protected-access\n    graph_rewrites = options._graph_rewrites()\n    graph_rewrite_configs = options._graph_rewrite_configs()\n    # pylint: enable=protected-access\n    if graph_rewrites:\n      if self._has_captured_ref():\n        warnings.warn(\n            \"tf.data graph rewrites are not compatible with tf.Variable. \"\n            \"The following rewrites will be disabled: %s. To enable \"\n            \"rewrites, use resource variables instead by calling \"\n            \"`tf.enable_resource_variables()` at the start of the program.\" %\n            \", \".join(graph_rewrites))\n      else:\n        dataset = _OptimizeDataset(dataset, graph_rewrites,\n                                   graph_rewrite_configs)\n\n    # (3) Apply autotune options\n    autotune, algorithm, cpu_budget = options._autotune_settings()  # pylint: disable=protected-access\n\n    if autotune:\n      dataset = _ModelDataset(dataset, algorithm, cpu_budget)\n\n    # (4) Apply stats aggregator options\n    if options.experimental_stats and options.experimental_stats.aggregator:  # pylint: disable=line-too-long\n      dataset = _SetStatsAggregatorDataset(  # pylint: disable=protected-access\n          dataset, options.experimental_stats.aggregator,\n          options.experimental_stats.prefix,\n          options.experimental_stats.counter_prefix)\n    return dataset\n\n  def __iter__(self):\n    \"\"\"Creates an `Iterator` for enumerating the elements of this dataset.\n\n    The returned iterator implements the Python iterator protocol and therefore\n    can only be used in eager mode.\n\n    Returns:\n      An `Iterator` over the elements of this dataset.\n\n    Raises:\n      RuntimeError: If not inside of tf.function and not executing eagerly.\n    \"\"\"\n    if context.executing_eagerly() or ops.inside_function():\n      return iterator_ops.OwnedIterator(self)\n    else:\n      raise RuntimeError(\"__iter__() is only supported inside of tf.function \"\n                         \"or when eager execution is enabled.\")\n\n  @abc.abstractproperty\n  def element_spec(self):\n    \"\"\"The type specification of an element of this dataset.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3]).element_spec\n    TensorSpec(shape=(), dtype=tf.int32, name=None)\n\n    Returns:\n      A nested structure of `tf.TypeSpec` objects matching the structure of an\n      element of this dataset and specifying the type of individual components.\n    \"\"\"\n    raise NotImplementedError(\"Dataset.element_spec\")\n\n  def __repr__(self):\n    output_shapes = nest.map_structure(str, get_legacy_output_shapes(self))\n    output_shapes = str(output_shapes).replace(\"'\", \"\")\n    output_types = nest.map_structure(repr, get_legacy_output_types(self))\n    output_types = str(output_types).replace(\"'\", \"\")\n    return (\"<%s shapes: %s, types: %s>\" % (type(self).__name__, output_shapes,\n                                            output_types))\n\n  def as_numpy_iterator(self):\n    \"\"\"Returns an iterator which converts all elements of the dataset to numpy.\n\n    Use `as_numpy_iterator` to inspect the content of your dataset. To see\n    element shapes and types, print dataset elements directly instead of using\n    `as_numpy_iterator`.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> for element in dataset:\n    ...   print(element)\n    tf.Tensor(1, shape=(), dtype=int32)\n    tf.Tensor(2, shape=(), dtype=int32)\n    tf.Tensor(3, shape=(), dtype=int32)\n\n    This method requires that you are running in eager mode and the dataset's\n    element_spec contains only `TensorSpec` components.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> for element in dataset.as_numpy_iterator():\n    ...   print(element)\n    1\n    2\n    3\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> print(list(dataset.as_numpy_iterator()))\n    [1, 2, 3]\n\n    `as_numpy_iterator()` will preserve the nested structure of dataset\n    elements.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices({'a': ([1, 2], [3, 4]),\n    ...                                               'b': [5, 6]})\n    >>> list(dataset.as_numpy_iterator()) == [{'a': (1, 3), 'b': 5},\n    ...                                       {'a': (2, 4), 'b': 6}]\n    True\n\n    Returns:\n      An iterable over the elements of the dataset, with their tensors converted\n      to numpy arrays.\n\n    Raises:\n      TypeError: if an element contains a non-`Tensor` value.\n      RuntimeError: if eager execution is not enabled.\n    \"\"\"\n    if not context.executing_eagerly():\n      raise RuntimeError(\"as_numpy_iterator() is not supported while tracing \"\n                         \"functions\")\n    for component_spec in nest.flatten(self.element_spec):\n      if not isinstance(component_spec, tensor_spec.TensorSpec):\n        raise TypeError(\n            \"Dataset.as_numpy_iterator() does not support datasets containing \"\n            + str(component_spec.value_type))\n\n    return _NumpyIterator(self)\n\n  @property\n  def _flat_shapes(self):\n    \"\"\"Returns a list `tf.TensorShapes`s for the element tensor representation.\n\n    Returns:\n      A list `tf.TensorShapes`s for the element tensor representation.\n    \"\"\"\n    return structure.get_flat_tensor_shapes(self.element_spec)\n\n  @property\n  def _flat_types(self):\n    \"\"\"Returns a list `tf.DType`s for the element tensor representation.\n\n    Returns:\n      A list `tf.DType`s for the element tensor representation.\n    \"\"\"\n    return structure.get_flat_tensor_types(self.element_spec)\n\n  @property\n  def _flat_structure(self):\n    \"\"\"Helper for setting `output_shapes` and `output_types` attrs of an op.\n\n    Most dataset op constructors expect `output_shapes` and `output_types`\n    arguments that represent the flattened structure of an element. This helper\n    function generates these attrs as a keyword argument dictionary, allowing\n    `Dataset._variant_tensor` implementations to pass `**self._flat_structure`\n    to the op constructor.\n\n    Returns:\n      A dictionary of keyword arguments that can be passed to a dataset op\n      constructor.\n    \"\"\"\n    return {\n        \"output_shapes\": self._flat_shapes,\n        \"output_types\": self._flat_types,\n    }\n\n  @property\n  def _type_spec(self):\n    return DatasetSpec(self.element_spec)\n\n  @staticmethod\n  def from_tensors(tensors):\n    \"\"\"Creates a `Dataset` with a single element, comprising the given tensors.\n\n    `from_tensors` produces a dataset containing only a single element. To slice\n    the input tensor into multiple elements, use `from_tensor_slices` instead.\n\n    >>> dataset = tf.data.Dataset.from_tensors([1, 2, 3])\n    >>> list(dataset.as_numpy_iterator())\n    [array([1, 2, 3], dtype=int32)]\n    >>> dataset = tf.data.Dataset.from_tensors(([1, 2, 3], 'A'))\n    >>> list(dataset.as_numpy_iterator())\n    [(array([1, 2, 3], dtype=int32), b'A')]\n\n    >>> # You can use `from_tensors` to produce a dataset which repeats\n    >>> # the same example many times.\n    >>> example = tf.constant([1,2,3])\n    >>> dataset = tf.data.Dataset.from_tensors(example).repeat(2)\n    >>> list(dataset.as_numpy_iterator())\n    [array([1, 2, 3], dtype=int32), array([1, 2, 3], dtype=int32)]\n\n    Note that if `tensors` contains a NumPy array, and eager execution is not\n    enabled, the values will be embedded in the graph as one or more\n    `tf.constant` operations. For large datasets (> 1 GB), this can waste\n    memory and run into byte limits of graph serialization. If `tensors`\n    contains one or more large NumPy arrays, consider the alternative described\n    in [this\n    guide](https://tensorflow.org/guide/data#consuming_numpy_arrays).\n\n    Args:\n      tensors: A dataset element.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return TensorDataset(tensors)\n\n  @staticmethod\n  def from_tensor_slices(tensors):\n    \"\"\"Creates a `Dataset` whose elements are slices of the given tensors.\n\n    The given tensors are sliced along their first dimension. This operation\n    preserves the structure of the input tensors, removing the first dimension\n    of each tensor and using it as the dataset dimension. All input tensors\n    must have the same size in their first dimensions.\n\n    >>> # Slicing a 1D tensor produces scalar tensor elements.\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> list(dataset.as_numpy_iterator())\n    [1, 2, 3]\n\n    >>> # Slicing a 2D tensor produces 1D tensor elements.\n    >>> dataset = tf.data.Dataset.from_tensor_slices([[1, 2], [3, 4]])\n    >>> list(dataset.as_numpy_iterator())\n    [array([1, 2], dtype=int32), array([3, 4], dtype=int32)]\n\n    >>> # Slicing a tuple of 1D tensors produces tuple elements containing\n    >>> # scalar tensors.\n    >>> dataset = tf.data.Dataset.from_tensor_slices(([1, 2], [3, 4], [5, 6]))\n    >>> list(dataset.as_numpy_iterator())\n    [(1, 3, 5), (2, 4, 6)]\n\n    >>> # Dictionary structure is also preserved.\n    >>> dataset = tf.data.Dataset.from_tensor_slices({\"a\": [1, 2], \"b\": [3, 4]})\n    >>> list(dataset.as_numpy_iterator()) == [{'a': 1, 'b': 3},\n    ...                                       {'a': 2, 'b': 4}]\n    True\n\n    >>> # Two tensors can be combined into one Dataset object.\n    >>> features = tf.constant([[1, 3], [2, 1], [3, 3]]) # ==> 3x2 tensor\n    >>> labels = tf.constant(['A', 'B', 'A']) # ==> 3x1 tensor\n    >>> dataset = Dataset.from_tensor_slices((features, labels))\n    >>> # Both the features and the labels tensors can be converted\n    >>> # to a Dataset object separately and combined after.\n    >>> features_dataset = Dataset.from_tensor_slices(features)\n    >>> labels_dataset = Dataset.from_tensor_slices(labels)\n    >>> dataset = Dataset.zip((features_dataset, labels_dataset))\n    >>> # A batched feature and label set can be converted to a Dataset\n    >>> # in similar fashion.\n    >>> batched_features = tf.constant([[[1, 3], [2, 3]],\n    ...                                 [[2, 1], [1, 2]],\n    ...                                 [[3, 3], [3, 2]]], shape=(3, 2, 2))\n    >>> batched_labels = tf.constant([['A', 'A'],\n    ...                               ['B', 'B'],\n    ...                               ['A', 'B']], shape=(3, 2, 1))\n    >>> dataset = Dataset.from_tensor_slices((batched_features, batched_labels))\n    >>> for element in dataset.as_numpy_iterator():\n    ...   print(element)\n    (array([[1, 3],\n           [2, 3]], dtype=int32), array([[b'A'],\n           [b'A']], dtype=object))\n    (array([[2, 1],\n           [1, 2]], dtype=int32), array([[b'B'],\n           [b'B']], dtype=object))\n    (array([[3, 3],\n           [3, 2]], dtype=int32), array([[b'A'],\n           [b'B']], dtype=object))\n\n    Note that if `tensors` contains a NumPy array, and eager execution is not\n    enabled, the values will be embedded in the graph as one or more\n    `tf.constant` operations. For large datasets (> 1 GB), this can waste\n    memory and run into byte limits of graph serialization. If `tensors`\n    contains one or more large NumPy arrays, consider the alternative described\n    in [this guide](\n    https://tensorflow.org/guide/data#consuming_numpy_arrays).\n\n    Args:\n      tensors: A dataset element, with each component having the same size in\n        the first dimension.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return TensorSliceDataset(tensors)\n\n  class _GeneratorState(object):\n    \"\"\"Stores outstanding iterators created from a Python generator.\n\n    This class keeps track of potentially multiple iterators that may have\n    been created from a generator, e.g. in the case that the dataset is\n    repeated, or nested within a parallel computation.\n    \"\"\"\n\n    def __init__(self, generator):\n      self._generator = generator\n      self._lock = threading.Lock()\n      self._next_id = 0  # GUARDED_BY(self._lock)\n      self._args = {}\n      self._iterators = {}\n\n    def get_next_id(self, *args):\n      with self._lock:\n        ret = self._next_id\n        self._next_id += 1\n      self._args[ret] = args\n      # NOTE(mrry): Explicitly create an array of `np.int64` because implicit\n      # casting in `py_func()` will create an array of `np.int32` on Windows,\n      # leading to a runtime error.\n      return np.array(ret, dtype=np.int64)\n\n    def get_iterator(self, iterator_id):\n      try:\n        return self._iterators[iterator_id]\n      except KeyError:\n        iterator = iter(self._generator(*self._args.pop(iterator_id)))\n        self._iterators[iterator_id] = iterator\n        return iterator\n\n    def iterator_completed(self, iterator_id):\n      del self._iterators[iterator_id]\n\n  @staticmethod\n  def from_generator(generator, output_types, output_shapes=None, args=None):\n    \"\"\"Creates a `Dataset` whose elements are generated by `generator`.\n\n    The `generator` argument must be a callable object that returns\n    an object that supports the `iter()` protocol (e.g. a generator function).\n    The elements generated by `generator` must be compatible with the given\n    `output_types` and (optional) `output_shapes` arguments.\n\n    >>> import itertools\n    >>>\n    >>> def gen():\n    ...   for i in itertools.count(1):\n    ...     yield (i, [1] * i)\n    >>>\n    >>> dataset = tf.data.Dataset.from_generator(\n    ...      gen,\n    ...      (tf.int64, tf.int64),\n    ...      (tf.TensorShape([]), tf.TensorShape([None])))\n    >>>\n    >>> list(dataset.take(3).as_numpy_iterator())\n    [(1, array([1])), (2, array([1, 1])), (3, array([1, 1, 1]))]\n\n    Note: The current implementation of `Dataset.from_generator()` uses\n    `tf.numpy_function` and inherits the same constraints. In particular, it\n    requires the `Dataset`- and `Iterator`-related operations to be placed\n    on a device in the same process as the Python program that called\n    `Dataset.from_generator()`. The body of `generator` will not be\n    serialized in a `GraphDef`, and you should not use this method if you\n    need to serialize your model and restore it in a different environment.\n\n    Note: If `generator` depends on mutable global variables or other external\n    state, be aware that the runtime may invoke `generator` multiple times\n    (in order to support repeating the `Dataset`) and at any time\n    between the call to `Dataset.from_generator()` and the production of the\n    first element from the generator. Mutating global variables or external\n    state can cause undefined behavior, and we recommend that you explicitly\n    cache any external state in `generator` before calling\n    `Dataset.from_generator()`.\n\n    Args:\n      generator: A callable object that returns an object that supports the\n        `iter()` protocol. If `args` is not specified, `generator` must take no\n        arguments; otherwise it must take as many arguments as there are values\n        in `args`.\n      output_types: A nested structure of `tf.DType` objects corresponding to\n        each component of an element yielded by `generator`.\n      output_shapes: (Optional.) A nested structure of `tf.TensorShape` objects\n        corresponding to each component of an element yielded by `generator`.\n      args: (Optional.) A tuple of `tf.Tensor` objects that will be evaluated\n        and passed to `generator` as NumPy-array arguments.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    if not callable(generator):\n      raise TypeError(\"`generator` must be callable.\")\n    if output_shapes is None:\n      output_shapes = nest.map_structure(\n          lambda _: tensor_shape.TensorShape(None), output_types)\n    else:\n      output_shapes = nest.map_structure_up_to(\n          output_types, tensor_shape.as_shape, output_shapes)\n    if args is None:\n      args = ()\n    else:\n      args = tuple(ops.convert_n_to_tensor(args, name=\"args\"))\n\n    flattened_types = [dtypes.as_dtype(dt) for dt in nest.flatten(output_types)]\n    flattened_shapes = nest.flatten(output_shapes)\n\n    generator_state = DatasetV2._GeneratorState(generator)\n\n    def get_iterator_id_fn(unused_dummy):\n      \"\"\"Creates a unique `iterator_id` for each pass over the dataset.\n\n      The returned `iterator_id` disambiguates between multiple concurrently\n      existing iterators.\n\n      Args:\n        unused_dummy: Ignored value.\n\n      Returns:\n        A `tf.int64` tensor whose value uniquely identifies an iterator in\n        `generator_state`.\n      \"\"\"\n      return script_ops.numpy_function(generator_state.get_next_id, args,\n                                       dtypes.int64)\n\n    def generator_next_fn(iterator_id_t):\n      \"\"\"Generates the next element from iterator with ID `iterator_id_t`.\n\n      We map this function across an infinite repetition of the\n      `iterator_id_t`, and raise `StopIteration` to terminate the iteration.\n\n      Args:\n        iterator_id_t: A `tf.int64` tensor whose value uniquely identifies the\n          iterator in `generator_state` from which to generate an element.\n\n      Returns:\n        The next element to generate from the iterator.\n      \"\"\"\n\n      def generator_py_func(iterator_id):\n        \"\"\"A `py_func` that will be called to invoke the iterator.\"\"\"\n        # `next()` raises `StopIteration` when there are no more\n        # elements remaining to be generated.\n        values = next(generator_state.get_iterator(iterator_id))\n\n        # Use the same _convert function from the py_func() implementation to\n        # convert the returned values to arrays early, so that we can inspect\n        # their values.\n        try:\n          flattened_values = nest.flatten_up_to(output_types, values)\n        except (TypeError, ValueError):\n          six.reraise(TypeError, TypeError(\n              \"`generator` yielded an element that did not match the expected \"\n              \"structure. The expected structure was %s, but the yielded \"\n              \"element was %s.\" % (output_types, values)), sys.exc_info()[2])\n        ret_arrays = []\n        for ret, dtype in zip(flattened_values, flattened_types):\n          try:\n            ret_arrays.append(script_ops.FuncRegistry._convert(  # pylint: disable=protected-access\n                ret, dtype=dtype.as_numpy_dtype))\n          except (TypeError, ValueError):\n            six.reraise(TypeError, TypeError(\n                \"`generator` yielded an element that could not be converted to \"\n                \"the expected type. The expected type was %s, but the yielded \"\n                \"element was %s.\" % (dtype.name, ret)), sys.exc_info()[2])\n\n        # Additional type and shape checking to ensure that the components\n        # of the generated element match the `output_types` and `output_shapes`\n        # arguments.\n        for (ret_array, expected_dtype, expected_shape) in zip(\n            ret_arrays, flattened_types, flattened_shapes):\n          if ret_array.dtype != expected_dtype.as_numpy_dtype:\n            raise TypeError(\n                \"`generator` yielded an element of type %s where an element \"\n                \"of type %s was expected.\" % (ret_array.dtype,\n                                              expected_dtype.as_numpy_dtype))\n          if not expected_shape.is_compatible_with(ret_array.shape):\n            raise ValueError(\n                \"`generator` yielded an element of shape %s where an element \"\n                \"of shape %s was expected.\" % (ret_array.shape, expected_shape))\n\n        return ret_arrays\n\n      flat_values = script_ops.numpy_function(generator_py_func,\n                                              [iterator_id_t], flattened_types)\n\n      # The `py_func()` op drops the inferred shapes, so we add them back in\n      # here.\n      if output_shapes is not None:\n        for ret_t, shape in zip(flat_values, flattened_shapes):\n          ret_t.set_shape(shape)\n\n      return nest.pack_sequence_as(output_types, flat_values)\n\n    def finalize_fn(iterator_id_t):\n      \"\"\"Releases host-side state for the iterator with ID `iterator_id_t`.\"\"\"\n\n      def finalize_py_func(iterator_id):\n        generator_state.iterator_completed(iterator_id)\n        # We return a dummy value so that the `finalize_fn` has a valid\n        # signature.\n        # NOTE(mrry): Explicitly create an array of `np.int64` because implicit\n        # casting in `py_func()` will create an array of `np.int32` on Windows,\n        # leading to a runtime error.\n        return np.array(0, dtype=np.int64)\n\n      return script_ops.numpy_function(finalize_py_func, [iterator_id_t],\n                                       dtypes.int64)\n\n    # This function associates each traversal of `generator` with a unique\n    # iterator ID.\n    def flat_map_fn(dummy_arg):\n      # The `get_iterator_id_fn` gets a unique ID for the current instance of\n      # of the generator.\n      # The `generator_next_fn` gets the next element from the iterator with the\n      # given ID, and raises StopIteration when that iterator contains no\n      # more elements.\n      return _GeneratorDataset(dummy_arg, get_iterator_id_fn, generator_next_fn,\n                               finalize_fn)\n\n    # A single-element dataset that, each time it is evaluated, contains a\n    # freshly-generated and unique (for the returned dataset) int64\n    # ID that will be used to identify the appropriate Python state, which\n    # is encapsulated in `generator_state`, and captured in\n    # `get_iterator_id_map_fn`.\n    dummy = 0\n    id_dataset = Dataset.from_tensors(dummy)\n\n    # A dataset that contains all of the elements generated by a\n    # single iterator created from `generator`, identified by the\n    # iterator ID contained in `id_dataset`. Lifting the iteration\n    # into a flat_map here enables multiple repetitions and/or nested\n    # versions of the returned dataset to be created, because it forces\n    # the generation of a new ID for each version.\n    return id_dataset.flat_map(flat_map_fn)\n\n  @staticmethod\n  def range(*args, **kwargs):\n    \"\"\"Creates a `Dataset` of a step-separated range of values.\n\n    >>> list(Dataset.range(5).as_numpy_iterator())\n    [0, 1, 2, 3, 4]\n    >>> list(Dataset.range(2, 5).as_numpy_iterator())\n    [2, 3, 4]\n    >>> list(Dataset.range(1, 5, 2).as_numpy_iterator())\n    [1, 3]\n    >>> list(Dataset.range(1, 5, -2).as_numpy_iterator())\n    []\n    >>> list(Dataset.range(5, 1).as_numpy_iterator())\n    []\n    >>> list(Dataset.range(5, 1, -2).as_numpy_iterator())\n    [5, 3]\n    >>> list(Dataset.range(2, 5, output_type=tf.int32).as_numpy_iterator())\n    [2, 3, 4]\n    >>> list(Dataset.range(1, 5, 2, output_type=tf.float32).as_numpy_iterator())\n    [1.0, 3.0]\n\n    Args:\n      *args: follows the same semantics as python's xrange.\n        len(args) == 1 -> start = 0, stop = args[0], step = 1.\n        len(args) == 2 -> start = args[0], stop = args[1], step = 1.\n        len(args) == 3 -> start = args[0], stop = args[1], step = args[2].\n      **kwargs:\n        - output_type: Its expected dtype. (Optional, default: `tf.int64`).\n\n    Returns:\n      Dataset: A `RangeDataset`.\n\n    Raises:\n      ValueError: if len(args) == 0.\n    \"\"\"\n    return RangeDataset(*args, **kwargs)\n\n  @staticmethod\n  def zip(datasets):\n    \"\"\"Creates a `Dataset` by zipping together the given datasets.\n\n    This method has similar semantics to the built-in `zip()` function\n    in Python, with the main difference being that the `datasets`\n    argument can be an arbitrary nested structure of `Dataset` objects.\n\n    >>> # The nested structure of the `datasets` argument determines the\n    >>> # structure of elements in the resulting dataset.\n    >>> a = tf.data.Dataset.range(1, 4)  # ==> [ 1, 2, 3 ]\n    >>> b = tf.data.Dataset.range(4, 7)  # ==> [ 4, 5, 6 ]\n    >>> ds = tf.data.Dataset.zip((a, b))\n    >>> list(ds.as_numpy_iterator())\n    [(1, 4), (2, 5), (3, 6)]\n    >>> ds = tf.data.Dataset.zip((b, a))\n    >>> list(ds.as_numpy_iterator())\n    [(4, 1), (5, 2), (6, 3)]\n    >>>\n    >>> # The `datasets` argument may contain an arbitrary number of datasets.\n    >>> c = tf.data.Dataset.range(7, 13).batch(2)  # ==> [ [7, 8],\n    ...                                            #       [9, 10],\n    ...                                            #       [11, 12] ]\n    >>> ds = tf.data.Dataset.zip((a, b, c))\n    >>> for element in ds.as_numpy_iterator():\n    ...   print(element)\n    (1, 4, array([7, 8]))\n    (2, 5, array([ 9, 10]))\n    (3, 6, array([11, 12]))\n    >>>\n    >>> # The number of elements in the resulting dataset is the same as\n    >>> # the size of the smallest dataset in `datasets`.\n    >>> d = tf.data.Dataset.range(13, 15)  # ==> [ 13, 14 ]\n    >>> ds = tf.data.Dataset.zip((a, d))\n    >>> list(ds.as_numpy_iterator())\n    [(1, 13), (2, 14)]\n\n    Args:\n      datasets: A nested structure of datasets.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return ZipDataset(datasets)\n\n  def concatenate(self, dataset):\n    \"\"\"Creates a `Dataset` by concatenating the given dataset with this dataset.\n\n    >>> a = tf.data.Dataset.range(1, 4)  # ==> [ 1, 2, 3 ]\n    >>> b = tf.data.Dataset.range(4, 8)  # ==> [ 4, 5, 6, 7 ]\n    >>> ds = a.concatenate(b)\n    >>> list(ds.as_numpy_iterator())\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> # The input dataset and dataset to be concatenated should have the same\n    >>> # nested structures and output types.\n    >>> c = tf.data.Dataset.zip((a, b))\n    >>> a.concatenate(c)\n    Traceback (most recent call last):\n    TypeError: Two datasets to concatenate have different types\n    <dtype: 'int64'> and (tf.int64, tf.int64)\n    >>> d = tf.data.Dataset.from_tensor_slices([\"a\", \"b\", \"c\"])\n    >>> a.concatenate(d)\n    Traceback (most recent call last):\n    TypeError: Two datasets to concatenate have different types\n    <dtype: 'int64'> and <dtype: 'string'>\n\n    Args:\n      dataset: `Dataset` to be concatenated.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return ConcatenateDataset(self, dataset)\n\n  def prefetch(self, buffer_size):\n    \"\"\"Creates a `Dataset` that prefetches elements from this dataset.\n\n    Most dataset input pipelines should end with a call to `prefetch`. This\n    allows later elements to be prepared while the current element is being\n    processed. This often improves latency and throughput, at the cost of\n    using additional memory to store prefetched elements.\n\n    Note: Like other `Dataset` methods, prefetch operates on the\n    elements of the input dataset. It has no concept of examples vs. batches.\n    `examples.prefetch(2)` will prefetch two elements (2 examples),\n    while `examples.batch(20).prefetch(2)` will prefetch 2 elements\n    (2 batches, of 20 examples each).\n\n    >>> dataset = tf.data.Dataset.range(3)\n    >>> dataset = dataset.prefetch(2)\n    >>> list(dataset.as_numpy_iterator())\n    [0, 1, 2]\n\n    Args:\n      buffer_size: A `tf.int64` scalar `tf.Tensor`, representing the maximum\n        number of elements that will be buffered when prefetching.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return PrefetchDataset(self, buffer_size)\n\n  @staticmethod\n  def list_files(file_pattern, shuffle=None, seed=None):\n    \"\"\"A dataset of all files matching one or more glob patterns.\n\n    The `file_pattern` argument should be a small number of glob patterns.\n    If your filenames have already been globbed, use\n    `Dataset.from_tensor_slices(filenames)` instead, as re-globbing every\n    filename with `list_files` may result in poor performance with remote\n    storage systems.\n\n    Note: The default behavior of this method is to return filenames in\n    a non-deterministic random shuffled order. Pass a `seed` or `shuffle=False`\n    to get results in a deterministic order.\n\n    Example:\n      If we had the following files on our filesystem:\n      \n        - /path/to/dir/a.txt\n        - /path/to/dir/b.py\n        - /path/to/dir/c.py\n      \n      If we pass \"/path/to/dir/*.py\" as the directory, the dataset\n      would produce:\n      \n        - /path/to/dir/b.py\n        - /path/to/dir/c.py\n\n    Args:\n      file_pattern: A string, a list of strings, or a `tf.Tensor` of string type\n        (scalar or vector), representing the filename glob (i.e. shell wildcard)\n        pattern(s) that will be matched.\n      shuffle: (Optional.) If `True`, the file names will be shuffled randomly.\n        Defaults to `True`.\n      seed: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the random\n        seed that will be used to create the distribution. See\n        `tf.random.set_seed` for behavior.\n\n    Returns:\n     Dataset: A `Dataset` of strings corresponding to file names.\n    \"\"\"\n    with ops.name_scope(\"list_files\"):\n      if shuffle is None:\n        shuffle = True\n      file_pattern = ops.convert_to_tensor(\n          file_pattern, dtype=dtypes.string, name=\"file_pattern\")\n      matching_files = gen_io_ops.matching_files(file_pattern)\n\n      # Raise an exception if `file_pattern` does not match any files.\n      condition = math_ops.greater(array_ops.shape(matching_files)[0], 0,\n                                   name=\"match_not_empty\")\n\n      message = math_ops.add(\n          \"No files matched pattern: \",\n          string_ops.reduce_join(file_pattern, separator=\", \"), name=\"message\")\n\n      assert_not_empty = control_flow_ops.Assert(\n          condition, [message], summarize=1, name=\"assert_not_empty\")\n      with ops.control_dependencies([assert_not_empty]):\n        matching_files = array_ops.identity(matching_files)\n\n      dataset = Dataset.from_tensor_slices(matching_files)\n      if shuffle:\n        # NOTE(mrry): The shuffle buffer size must be greater than zero, but the\n        # list of files might be empty.\n        buffer_size = math_ops.maximum(\n            array_ops.shape(matching_files, out_type=dtypes.int64)[0], 1)\n        dataset = dataset.shuffle(buffer_size, seed=seed)\n      return dataset\n\n  def repeat(self, count=None):\n    \"\"\"Repeats this dataset so each original value is seen `count` times.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> dataset = dataset.repeat(3)\n    >>> list(dataset.as_numpy_iterator())\n    [1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n    Note: If this dataset is a function of global state (e.g. a random number\n    generator), then different repetitions may produce different elements.\n\n    Args:\n      count: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the\n        number of times the dataset should be repeated. The default behavior (if\n        `count` is `None` or `-1`) is for the dataset be repeated indefinitely.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return RepeatDataset(self, count)\n\n  def enumerate(self, start=0):\n    \"\"\"Enumerates the elements of this dataset.\n\n    It is similar to python's `enumerate`.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> dataset = dataset.enumerate(start=5)\n    >>> for element in dataset.as_numpy_iterator():\n    ...   print(element)\n    (5, 1)\n    (6, 2)\n    (7, 3)\n\n    >>> # The nested structure of the input dataset determines the structure of\n    >>> # elements in the resulting dataset.\n    >>> dataset = tf.data.Dataset.from_tensor_slices([(7, 8), (9, 10)])\n    >>> dataset = dataset.enumerate()\n    >>> for element in dataset.as_numpy_iterator():\n    ...   print(element)\n    (0, array([7, 8], dtype=int32))\n    (1, array([ 9, 10], dtype=int32))\n\n    Args:\n      start: A `tf.int64` scalar `tf.Tensor`, representing the start value for\n        enumeration.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n\n    max_value = np.iinfo(dtypes.int64.as_numpy_dtype).max\n    return Dataset.zip((Dataset.range(start, max_value), self))\n\n  def shuffle(self, buffer_size, seed=None, reshuffle_each_iteration=None):\n    \"\"\"Randomly shuffles the elements of this dataset.\n\n    This dataset fills a buffer with `buffer_size` elements, then randomly\n    samples elements from this buffer, replacing the selected elements with new\n    elements. For perfect shuffling, a buffer size greater than or equal to the\n    full size of the dataset is required.\n\n    For instance, if your dataset contains 10,000 elements but `buffer_size` is\n    set to 1,000, then `shuffle` will initially select a random element from\n    only the first 1,000 elements in the buffer. Once an element is selected,\n    its space in the buffer is replaced by the next (i.e. 1,001-st) element,\n    maintaining the 1,000 element buffer.\n\n    `reshuffle_each_iteration` controls whether the shuffle order should be\n    different for each epoch. In TF 1.X, the idiomatic way to create epochs\n    was through the `repeat` transformation:\n\n    >>> dataset = tf.data.Dataset.range(3)\n    >>> dataset = dataset.shuffle(3, reshuffle_each_iteration=True)\n    >>> dataset = dataset.repeat(2)  # doctest: +SKIP\n    [1, 0, 2, 1, 2, 0]\n\n    >>> dataset = tf.data.Dataset.range(3)\n    >>> dataset = dataset.shuffle(3, reshuffle_each_iteration=False)\n    >>> dataset = dataset.repeat(2)  # doctest: +SKIP\n    [1, 0, 2, 1, 0, 2]\n\n    In TF 2.0, `tf.data.Dataset` objects are Python iterables which makes it\n    possible to also create epochs through Python iteration:\n\n    >>> dataset = tf.data.Dataset.range(3)\n    >>> dataset = dataset.shuffle(3, reshuffle_each_iteration=True)\n    >>> list(dataset.as_numpy_iterator())  # doctest: +SKIP\n    [1, 0, 2]\n    >>> list(dataset.as_numpy_iterator())  # doctest: +SKIP\n    [1, 2, 0]\n\n    >>> dataset = tf.data.Dataset.range(3)\n    >>> dataset = dataset.shuffle(3, reshuffle_each_iteration=False)\n    >>> list(dataset.as_numpy_iterator())  # doctest: +SKIP\n    [1, 0, 2]\n    >>> list(dataset.as_numpy_iterator())  # doctest: +SKIP\n    [1, 0, 2]\n\n    Args:\n      buffer_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        elements from this dataset from which the new dataset will sample.\n      seed: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the random\n        seed that will be used to create the distribution. See\n        `tf.random.set_seed` for behavior.\n      reshuffle_each_iteration: (Optional.) A boolean, which if true indicates\n        that the dataset should be pseudorandomly reshuffled each time it is\n        iterated over. (Defaults to `True`.)\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return ShuffleDataset(self, buffer_size, seed, reshuffle_each_iteration)\n\n  def cache(self, filename=\"\"):\n    \"\"\"Caches the elements in this dataset.\n\n    The first time the dataset is iterated over, its elements will be cached\n    either in the specified file or in memory. Subsequent iterations will\n    use the cached data.\n\n    Note: For the cache to be finalized, the input dataset must be iterated\n    through in its entirety. Otherwise, subsequent iterations will not use\n    cached data.\n\n    >>> dataset = tf.data.Dataset.range(5)\n    >>> dataset = dataset.map(lambda x: x**2)\n    >>> dataset = dataset.cache()\n    >>> # The first time reading through the data will generate the data using\n    >>> # `range` and `map`.\n    >>> list(dataset.as_numpy_iterator())\n    [0, 1, 4, 9, 16]\n    >>> # Subsequent iterations read from the cache.\n    >>> list(dataset.as_numpy_iterator())\n    [0, 1, 4, 9, 16]\n\n    When caching to a file, the cached data will persist across runs. Even the\n    first iteration through the data will read from the cache file. Changing\n    the input pipeline before the call to `.cache()` will have no effect until\n    the cache file is removed or the filename is changed.\n\n    >>> dataset = tf.data.Dataset.range(5)\n    >>> dataset = dataset.cache(\"/path/to/file\")  # doctest: +SKIP\n    >>> list(dataset.as_numpy_iterator())  # doctest: +SKIP\n    [0, 1, 2, 3, 4]\n    >>> dataset = tf.data.Dataset.range(10)\n    >>> dataset = dataset.cache(\"/path/to/file\")  # Same file! # doctest: +SKIP\n    >>> list(dataset.as_numpy_iterator())  # doctest: +SKIP\n    [0, 1, 2, 3, 4]\n\n    Note: `cache` will produce exactly the same elements during each iteration\n    through the dataset. If you wish to randomize the iteration order, make sure\n    to call `shuffle` *after* calling `cache`.\n\n    Args:\n      filename: A `tf.string` scalar `tf.Tensor`, representing the name of a\n        directory on the filesystem to use for caching elements in this Dataset.\n        If a filename is not provided, the dataset will be cached in memory.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return CacheDataset(self, filename)\n\n  def take(self, count):\n    \"\"\"Creates a `Dataset` with at most `count` elements from this dataset.\n\n    >>> dataset = tf.data.Dataset.range(10)\n    >>> dataset = dataset.take(3)\n    >>> list(dataset.as_numpy_iterator())\n    [0, 1, 2]\n\n    Args:\n      count: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        elements of this dataset that should be taken to form the new dataset.\n        If `count` is -1, or if `count` is greater than the size of this\n        dataset, the new dataset will contain all elements of this dataset.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return TakeDataset(self, count)\n\n  def skip(self, count):\n    \"\"\"Creates a `Dataset` that skips `count` elements from this dataset.\n\n    >>> dataset = tf.data.Dataset.range(10)\n    >>> dataset = dataset.skip(7)\n    >>> list(dataset.as_numpy_iterator())\n    [7, 8, 9]\n\n    Args:\n      count: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        elements of this dataset that should be skipped to form the new dataset.\n        If `count` is greater than the size of this dataset, the new dataset\n        will contain no elements.  If `count` is -1, skips the entire dataset.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return SkipDataset(self, count)\n\n  def shard(self, num_shards, index):\n    \"\"\"Creates a `Dataset` that includes only 1/`num_shards` of this dataset.\n\n    `shard` is deterministic. The Dataset produced by `A.shard(n, i)` will\n    contain all elements of A whose index mod n = i.\n\n    >>> A = tf.data.Dataset.range(10)\n    >>> B = A.shard(num_shards=3, index=0)\n    >>> list(B.as_numpy_iterator())\n    [0, 3, 6, 9]\n    >>> C = A.shard(num_shards=3, index=1)\n    >>> list(C.as_numpy_iterator())\n    [1, 4, 7]\n    >>> D = A.shard(num_shards=3, index=2)\n    >>> list(D.as_numpy_iterator())\n    [2, 5, 8]\n\n    This dataset operator is very useful when running distributed training, as\n    it allows each worker to read a unique subset.\n\n    When reading a single input file, you can shard elements as follows:\n\n    ```python\n    d = tf.data.TFRecordDataset(input_file)\n    d = d.shard(num_workers, worker_index)\n    d = d.repeat(num_epochs)\n    d = d.shuffle(shuffle_buffer_size)\n    d = d.map(parser_fn, num_parallel_calls=num_map_threads)\n    ```\n\n    Important caveats:\n\n    - Be sure to shard before you use any randomizing operator (such as\n      shuffle).\n    - Generally it is best if the shard operator is used early in the dataset\n      pipeline. For example, when reading from a set of TFRecord files, shard\n      before converting the dataset to input samples. This avoids reading every\n      file on every worker. The following is an example of an efficient\n      sharding strategy within a complete pipeline:\n\n    ```python\n    d = Dataset.list_files(pattern)\n    d = d.shard(num_workers, worker_index)\n    d = d.repeat(num_epochs)\n    d = d.shuffle(shuffle_buffer_size)\n    d = d.interleave(tf.data.TFRecordDataset,\n                     cycle_length=num_readers, block_length=1)\n    d = d.map(parser_fn, num_parallel_calls=num_map_threads)\n    ```\n\n    Args:\n      num_shards: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        shards operating in parallel.\n      index: A `tf.int64` scalar `tf.Tensor`, representing the worker index.\n\n    Returns:\n      Dataset: A `Dataset`.\n\n    Raises:\n      InvalidArgumentError: if `num_shards` or `index` are illegal values.\n      \n        Note: error checking is done on a best-effort basis, and errors aren't\n        guaranteed to be caught upon dataset creation. (e.g. providing in a\n        placeholder tensor bypasses the early checking, and will instead result\n        in an error during a session.run call.)\n    \"\"\"\n    return ShardDataset(self, num_shards, index)\n\n  def batch(self, batch_size, drop_remainder=False):\n    \"\"\"Combines consecutive elements of this dataset into batches.\n\n    >>> dataset = tf.data.Dataset.range(8)\n    >>> dataset = dataset.batch(3)\n    >>> list(dataset.as_numpy_iterator())\n    [array([0, 1, 2]), array([3, 4, 5]), array([6, 7])]\n\n    >>> dataset = tf.data.Dataset.range(8)\n    >>> dataset = dataset.batch(3, drop_remainder=True)\n    >>> list(dataset.as_numpy_iterator())\n    [array([0, 1, 2]), array([3, 4, 5])]\n\n    The components of the resulting element will have an additional outer\n    dimension, which will be `batch_size` (or `N % batch_size` for the last\n    element if `batch_size` does not divide the number of input elements `N`\n    evenly and `drop_remainder` is `False`). If your program depends on the\n    batches having the same outer dimension, you should set the `drop_remainder`\n    argument to `True` to prevent the smaller batch from being produced.\n\n    Args:\n      batch_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        consecutive elements of this dataset to combine in a single batch.\n      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\n        whether the last batch should be dropped in the case it has fewer than\n        `batch_size` elements; the default behavior is not to drop the smaller\n        batch.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return BatchDataset(self, batch_size, drop_remainder)\n\n  def padded_batch(self,\n                   batch_size,\n                   padded_shapes=None,\n                   padding_values=None,\n                   drop_remainder=False):\n    \"\"\"Combines consecutive elements of this dataset into padded batches.\n\n    This transformation combines multiple consecutive elements of the input\n    dataset into a single element.\n\n    Like `tf.data.Dataset.batch`, the components of the resulting element will\n    have an additional outer dimension, which will be `batch_size` (or\n    `N % batch_size` for the last element if `batch_size` does not divide the\n    number of input elements `N` evenly and `drop_remainder` is `False`). If\n    your program depends on the batches having the same outer dimension, you\n    should set the `drop_remainder` argument to `True` to prevent the smaller\n    batch from being produced.\n\n    Unlike `tf.data.Dataset.batch`, the input elements to be batched may have\n    different shapes, and this transformation will pad each component to the\n    respective shape in `padded_shapes`. The `padded_shapes` argument\n    determines the resulting shape for each dimension of each component in an\n    output element:\n\n    * If the dimension is a constant, the component will be padded out to that\n      length in that dimension.\n    * If the dimension is unknown, the component will be padded out to the\n      maximum length of all elements in that dimension.\n\n    >>> A = (tf.data.Dataset\n    ...      .range(1, 5, output_type=tf.int32)\n    ...      .map(lambda x: tf.fill([x], x)))\n    >>> # Pad to the smallest per-batch size that fits all elements.\n    >>> B = A.padded_batch(2)\n    >>> for element in B.as_numpy_iterator():\n    ...   print(element)\n    [[1 0]\n     [2 2]]\n    [[3 3 3 0]\n     [4 4 4 4]]\n    >>> # Pad to a fixed size.\n    >>> C = A.padded_batch(2, padded_shapes=5)\n    >>> for element in C.as_numpy_iterator():\n    ...   print(element)\n    [[1 0 0 0 0]\n     [2 2 0 0 0]]\n    [[3 3 3 0 0]\n     [4 4 4 4 0]]\n    >>> # Pad with a custom value.\n    >>> D = A.padded_batch(2, padded_shapes=5, padding_values=-1)\n    >>> for element in D.as_numpy_iterator():\n    ...   print(element)\n    [[ 1 -1 -1 -1 -1]\n     [ 2  2 -1 -1 -1]]\n    [[ 3  3  3 -1 -1]\n     [ 4  4  4  4 -1]]\n    >>> # Components of nested elements can be padded independently.\n    >>> elements = [([1, 2, 3], [10]),\n    ...             ([4, 5], [11, 12])]\n    >>> dataset = tf.data.Dataset.from_generator(\n    ...     lambda: iter(elements), (tf.int32, tf.int32))\n    >>> # Pad the first component of the tuple to length 4, and the second\n    >>> # component to the smallest size that fits.\n    >>> dataset = dataset.padded_batch(2,\n    ...     padded_shapes=([4], [None]),\n    ...     padding_values=(-1, 100))\n    >>> list(dataset.as_numpy_iterator())\n    [(array([[ 1,  2,  3, -1], [ 4,  5, -1, -1]], dtype=int32),\n      array([[ 10, 100], [ 11,  12]], dtype=int32))]\n\n    See also `tf.data.experimental.dense_to_sparse_batch`, which combines\n    elements that may have different shapes into a `tf.SparseTensor`.\n\n    Args:\n      batch_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        consecutive elements of this dataset to combine in a single batch.\n      padded_shapes: (Optional.) A nested structure of `tf.TensorShape` or\n        `tf.int64` vector tensor-like objects representing the shape to which\n        the respective component of each input element should be padded prior\n        to batching. Any unknown dimensions will be padded to the maximum size\n        of that dimension in each batch. If unset, all dimensions of all\n        components are padded to the maximum size in the batch. `padded_shapes`\n        must be set if any component has an unknown rank.\n      padding_values: (Optional.) A nested structure of scalar-shaped\n        `tf.Tensor`, representing the padding values to use for the respective\n        components. None represents that the nested structure should be padded\n        with default values.  Defaults are `0` for numeric types and the empty\n        string for string types.\n      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\n        whether the last batch should be dropped in the case it has fewer than\n        `batch_size` elements; the default behavior is not to drop the smaller\n        batch.\n\n    Returns:\n      Dataset: A `Dataset`.\n\n    Raises:\n      ValueError: If a component has an unknown rank, and  the `padded_shapes`\n        argument is not set.\n    \"\"\"\n    if padded_shapes is None:\n      padded_shapes = get_legacy_output_shapes(self)\n      # A `tf.TensorShape` only is only falsey if its *rank* is unknown:\n      # bool(tf.TensorShape(None)) is False\n      if not all(nest.flatten(padded_shapes)):\n        raise ValueError(\"You must set the `padded_shapes` argument to \"\n                         \"`Dataset.padded_batch` if any component of its \"\n                         \"input has an unknown rank\")\n    return PaddedBatchDataset(self, batch_size, padded_shapes, padding_values,\n                              drop_remainder)\n\n  def map(self, map_func, num_parallel_calls=None, deterministic=None):\n    \"\"\"Maps `map_func` across the elements of this dataset.\n\n    This transformation applies `map_func` to each element of this dataset, and\n    returns a new dataset containing the transformed elements, in the same\n    order as they appeared in the input. `map_func` can be used to change both\n    the values and the structure of a dataset's elements. For example, adding 1\n    to each element, or projecting a subset of element components.\n\n    >>> dataset = Dataset.range(1, 6)  # ==> [ 1, 2, 3, 4, 5 ]\n    >>> dataset = dataset.map(lambda x: x + 1)\n    >>> list(dataset.as_numpy_iterator())\n    [2, 3, 4, 5, 6]\n\n    The input signature of `map_func` is determined by the structure of each\n    element in this dataset.\n\n    >>> dataset = Dataset.range(5)\n    >>> # `map_func` takes a single argument of type `tf.Tensor` with the same\n    >>> # shape and dtype.\n    >>> result = dataset.map(lambda x: x + 1)\n\n    >>> # Each element is a tuple containing two `tf.Tensor` objects.\n    >>> elements = [(1, \"foo\"), (2, \"bar\"), (3, \"baz)\")]\n    >>> dataset = tf.data.Dataset.from_generator(\n    ...     lambda: elements, (tf.int32, tf.string))\n    >>> # `map_func` takes two arguments of type `tf.Tensor`. This function\n    >>> # projects out just the first component.\n    >>> result = dataset.map(lambda x_int, y_str: x_int)\n    >>> list(result.as_numpy_iterator())\n    [1, 2, 3]\n\n    >>> # Each element is a dictionary mapping strings to `tf.Tensor` objects.\n    >>> elements =  ([{\"a\": 1, \"b\": \"foo\"},\n    ...               {\"a\": 2, \"b\": \"bar\"},\n    ...               {\"a\": 3, \"b\": \"baz\"}])\n    >>> dataset = tf.data.Dataset.from_generator(\n    ...     lambda: elements, {\"a\": tf.int32, \"b\": tf.string})\n    >>> # `map_func` takes a single argument of type `dict` with the same keys\n    >>> # as the elements.\n    >>> result = dataset.map(lambda d: str(d[\"a\"]) + d[\"b\"])\n\n    The value or values returned by `map_func` determine the structure of each\n    element in the returned dataset.\n\n    >>> dataset = tf.data.Dataset.range(3)\n    >>> # `map_func` returns two `tf.Tensor` objects.\n    >>> def g(x):\n    ...   return tf.constant(37.0), tf.constant([\"Foo\", \"Bar\", \"Baz\"])\n    >>> result = dataset.map(g)\n    >>> result.element_spec\n    (TensorSpec(shape=(), dtype=tf.float32, name=None), TensorSpec(shape=(3,), \\\ndtype=tf.string, name=None))\n    >>> # Python primitives, lists, and NumPy arrays are implicitly converted to\n    >>> # `tf.Tensor`.\n    >>> def h(x):\n    ...   return 37.0, [\"Foo\", \"Bar\"], np.array([1.0, 2.0], dtype=np.float64)\n    >>> result = dataset.map(h)\n    >>> result.element_spec\n    (TensorSpec(shape=(), dtype=tf.float32, name=None), TensorSpec(shape=(2,), \\\ndtype=tf.string, name=None), TensorSpec(shape=(2,), dtype=tf.float64, \\\nname=None))\n    >>> # `map_func` can return nested structures.\n    >>> def i(x):\n    ...   return (37.0, [42, 16]), \"foo\"\n    >>> result = dataset.map(i)\n    >>> result.element_spec\n    ((TensorSpec(shape=(), dtype=tf.float32, name=None),\n      TensorSpec(shape=(2,), dtype=tf.int32, name=None)),\n     TensorSpec(shape=(), dtype=tf.string, name=None))\n\n    `map_func` can accept as arguments and return any type of dataset element.\n\n    Note that irrespective of the context in which `map_func` is defined (eager\n    vs. graph), tf.data traces the function and executes it as a graph. To use\n    Python code inside of the function you have two options:\n\n    1) Rely on AutoGraph to convert Python code into an equivalent graph\n    computation. The downside of this approach is that AutoGraph can convert\n    some but not all Python code.\n\n    2) Use `tf.py_function`, which allows you to write arbitrary Python code but\n    will generally result in worse performance than 1). For example:\n\n    >>> d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])\n    >>> # transform a string tensor to upper case string using a Python function\n    >>> def upper_case_fn(t: tf.Tensor):\n    ...   return t.numpy().decode('utf-8').upper()\n    >>> d = d.map(lambda x: tf.py_function(func=upper_case_fn,\n    ...           inp=[x], Tout=tf.string))\n    >>> list(d.as_numpy_iterator())\n    [b'HELLO', b'WORLD']\n\n    Performance can often be improved by setting `num_parallel_calls` so that\n    `map` will use multiple threads to process elements. If deterministic order\n    isn't required, it can also improve performance to set\n    `deterministic=False`.\n\n    >>> dataset = Dataset.range(1, 6)  # ==> [ 1, 2, 3, 4, 5 ]\n    >>> dataset = dataset.map(lambda x: x + 1,\n    ...     num_parallel_calls=tf.data.experimental.AUTOTUNE,\n    ...     deterministic=False)\n\n    Args:\n      map_func: A function mapping a dataset element to another dataset element.\n      num_parallel_calls: (Optional.) A `tf.int32` scalar `tf.Tensor`,\n        representing the number elements to process asynchronously in parallel.\n        If not specified, elements will be processed sequentially. If the value\n        `tf.data.experimental.AUTOTUNE` is used, then the number of parallel\n        calls is set dynamically based on available CPU.\n      deterministic: (Optional.) A boolean controlling whether determinism\n        should be traded for performance by allowing elements to be produced out\n        of order.  If `deterministic` is `None`, the\n        `tf.data.Options.experimental_deterministic` dataset option (`True` by\n        default) is used to decide whether to produce elements\n        deterministically.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    if num_parallel_calls is None:\n      return MapDataset(self, map_func, preserve_cardinality=True)\n    else:\n      return ParallelMapDataset(\n          self,\n          map_func,\n          num_parallel_calls,\n          deterministic,\n          preserve_cardinality=True)\n\n  def flat_map(self, map_func):\n    \"\"\"Maps `map_func` across this dataset and flattens the result.\n\n    Use `flat_map` if you want to make sure that the order of your dataset\n    stays the same. For example, to flatten a dataset of batches into a\n    dataset of their elements:\n\n    >>> dataset = Dataset.from_tensor_slices([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> dataset = dataset.flat_map(lambda x: Dataset.from_tensor_slices(x))\n    >>> list(dataset.as_numpy_iterator())\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    `tf.data.Dataset.interleave()` is a generalization of `flat_map`, since\n    `flat_map` produces the same output as\n    `tf.data.Dataset.interleave(cycle_length=1)`\n\n    Args:\n      map_func: A function mapping a dataset element to a dataset.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    return FlatMapDataset(self, map_func)\n\n  def interleave(self,\n                 map_func,\n                 cycle_length=AUTOTUNE,\n                 block_length=1,\n                 num_parallel_calls=None,\n                 deterministic=None):\n    \"\"\"Maps `map_func` across this dataset, and interleaves the results.\n\n    For example, you can use `Dataset.interleave()` to process many input files\n    concurrently:\n\n    >>> # Preprocess 4 files concurrently, and interleave blocks of 16 records\n    >>> # from each file.\n    >>> filenames = [\"/var/data/file1.txt\", \"/var/data/file2.txt\",\n    ...              \"/var/data/file3.txt\", \"/var/data/file4.txt\"]\n    >>> dataset = tf.data.Dataset.from_tensor_slices(filenames)\n    >>> def parse_fn(filename):\n    ...   return tf.data.Dataset.range(10)\n    >>> dataset = dataset.interleave(lambda x:\n    ...     tf.data.TextLineDataset(x).map(parse_fn, num_parallel_calls=1),\n    ...     cycle_length=4, block_length=16)\n\n    The `cycle_length` and `block_length` arguments control the order in which\n    elements are produced. `cycle_length` controls the number of input elements\n    that are processed concurrently. If you set `cycle_length` to 1, this\n    transformation will handle one input element at a time, and will produce\n    identical results to `tf.data.Dataset.flat_map`. In general,\n    this transformation will apply `map_func` to `cycle_length` input elements,\n    open iterators on the returned `Dataset` objects, and cycle through them\n    producing `block_length` consecutive elements from each iterator, and\n    consuming the next input element each time it reaches the end of an\n    iterator.\n\n    For example:\n\n    >>> dataset = Dataset.range(1, 6)  # ==> [ 1, 2, 3, 4, 5 ]\n    >>> # NOTE: New lines indicate \"block\" boundaries.\n    >>> dataset = dataset.interleave(\n    ...     lambda x: Dataset.from_tensors(x).repeat(6),\n    ...     cycle_length=2, block_length=4)\n    >>> list(dataset.as_numpy_iterator())\n    [1, 1, 1, 1,\n     2, 2, 2, 2,\n     1, 1,\n     2, 2,\n     3, 3, 3, 3,\n     4, 4, 4, 4,\n     3, 3,\n     4, 4,\n     5, 5, 5, 5,\n     5, 5]\n\n    Note: The order of elements yielded by this transformation is\n    deterministic, as long as `map_func` is a pure function and\n    `deterministic=True`. If `map_func` contains any stateful operations, the\n    order in which that state is accessed is undefined.\n\n    Performance can often be improved by setting `num_parallel_calls` so that\n    `interleave` will use multiple threads to fetch elements. If determinism\n    isn't required, it can also improve performance to set\n    `deterministic=False`.\n\n    >>> filenames = [\"/var/data/file1.txt\", \"/var/data/file2.txt\",\n    ...              \"/var/data/file3.txt\", \"/var/data/file4.txt\"]\n    >>> dataset = tf.data.Dataset.from_tensor_slices(filenames)\n    >>> dataset = dataset.interleave(lambda x: tf.data.TFRecordDataset(x),\n    ...     cycle_length=4, num_parallel_calls=tf.data.experimental.AUTOTUNE,\n    ...     deterministic=False)\n\n    Args:\n      map_func: A function mapping a dataset element to a dataset.\n      cycle_length: (Optional.) The number of input elements that will be\n        processed concurrently. If not specified, the value will be derived from\n        the number of available CPU cores. If the `num_parallel_calls` argument\n        is set to `tf.data.experimental.AUTOTUNE`, the `cycle_length` argument\n        also identifies the maximum degree of parallelism.\n      block_length: (Optional.) The number of consecutive elements to produce\n        from each input element before cycling to another input element.\n      num_parallel_calls: (Optional.) If specified, the implementation creates a\n        threadpool, which is used to fetch inputs from cycle elements\n        asynchronously and in parallel. The default behavior is to fetch inputs\n        from cycle elements synchronously with no parallelism. If the value\n        `tf.data.experimental.AUTOTUNE` is used, then the number of parallel\n        calls is set dynamically based on available CPU.\n      deterministic: (Optional.) A boolean controlling whether determinism\n        should be traded for performance by allowing elements to be produced out\n        of order.  If `deterministic` is `None`, the\n        `tf.data.Options.experimental_deterministic` dataset option (`True` by\n        default) is used to decide whether to produce elements\n        deterministically.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    if num_parallel_calls is None:\n      return InterleaveDataset(self, map_func, cycle_length, block_length)\n    else:\n      return ParallelInterleaveDataset(\n          self,\n          map_func,\n          cycle_length,\n          block_length,\n          num_parallel_calls,\n          deterministic=deterministic)\n\n  def filter(self, predicate):\n    \"\"\"Filters this dataset according to `predicate`.\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\n    >>> dataset = dataset.filter(lambda x: x < 3)\n    >>> list(dataset.as_numpy_iterator())\n    [1, 2]\n    >>> # `tf.math.equal(x, y)` is required for equality comparison\n    >>> def filter_fn(x):\n    ...   return tf.math.equal(x, 1)\n    >>> dataset = dataset.filter(filter_fn)\n    >>> list(dataset.as_numpy_iterator())\n    [1]\n\n    Args:\n      predicate: A function mapping a dataset element to a boolean.\n\n    Returns:\n      Dataset: The `Dataset` containing the elements of this dataset for which\n          `predicate` is `True`.\n    \"\"\"\n    return FilterDataset(self, predicate)\n\n  def apply(self, transformation_func):\n    \"\"\"Applies a transformation function to this dataset.\n\n    `apply` enables chaining of custom `Dataset` transformations, which are\n    represented as functions that take one `Dataset` argument and return a\n    transformed `Dataset`.\n\n    >>> dataset = tf.data.Dataset.range(100)\n    >>> def dataset_fn(ds):\n    ...   return ds.filter(lambda x: x < 5)\n    >>> dataset = dataset.apply(dataset_fn)\n    >>> list(dataset.as_numpy_iterator())\n    [0, 1, 2, 3, 4]\n\n    Args:\n      transformation_func: A function that takes one `Dataset` argument and\n        returns a `Dataset`.\n\n    Returns:\n      Dataset: The `Dataset` returned by applying `transformation_func` to this\n          dataset.\n    \"\"\"\n    dataset = transformation_func(self)\n    if not isinstance(dataset, DatasetV2):\n      raise TypeError(\n          \"`transformation_func` must return a Dataset. Got {}.\".format(\n              dataset))\n    dataset._input_datasets = [self]  # pylint: disable=protected-access\n    return dataset\n\n  def window(self, size, shift=None, stride=1, drop_remainder=False):\n    \"\"\"Combines (nests of) input elements into a dataset of (nests of) windows.\n\n    A \"window\" is a finite dataset of flat elements of size `size` (or possibly\n    fewer if there are not enough input elements to fill the window and\n    `drop_remainder` evaluates to `False`).\n\n    The `shift` argument determines the number of input elements by which the\n    window moves on each iteration.  If windows and elements are both numbered\n    starting at 0, the first element in window `k` will be element `k * shift`\n    of the input dataset. In particular, the first element of the first window\n    will always be the first element of the input dataset.\n\n    The `stride` argument determines the stride of the input elements, and the\n    `shift` argument determines the shift of the window.\n\n    For example:\n\n    >>> dataset = tf.data.Dataset.range(7).window(2)\n    >>> for window in dataset:\n    ...   print(list(window.as_numpy_iterator()))\n    [0, 1]\n    [2, 3]\n    [4, 5]\n    [6]\n    >>> dataset = tf.data.Dataset.range(7).window(3, 2, 1, True)\n    >>> for window in dataset:\n    ...   print(list(window.as_numpy_iterator()))\n    [0, 1, 2]\n    [2, 3, 4]\n    [4, 5, 6]\n    >>> dataset = tf.data.Dataset.range(7).window(3, 1, 2, True)\n    >>> for window in dataset:\n    ...   print(list(window.as_numpy_iterator()))\n    [0, 2, 4]\n    [1, 3, 5]\n    [2, 4, 6]\n\n    Note that when the `window` transformation is applied to a dataset of\n    nested elements, it produces a dataset of nested windows.\n\n    >>> nested = ([1, 2, 3, 4], [5, 6, 7, 8])\n    >>> dataset = tf.data.Dataset.from_tensor_slices(nested).window(2)\n    >>> for window in dataset:\n    ...   def to_numpy(ds):\n    ...     return list(ds.as_numpy_iterator())\n    ...   print(tuple(to_numpy(component) for component in window))\n    ([1, 2], [5, 6])\n    ([3, 4], [7, 8])\n\n    >>> dataset = tf.data.Dataset.from_tensor_slices({'a': [1, 2, 3, 4]})\n    >>> dataset = dataset.window(2)\n    >>> for window in dataset:\n    ...   def to_numpy(ds):\n    ...     return list(ds.as_numpy_iterator())\n    ...   print({'a': to_numpy(window['a'])})\n    {'a': [1, 2]}\n    {'a': [3, 4]}\n\n    Args:\n      size: A `tf.int64` scalar `tf.Tensor`, representing the number of elements\n        of the input dataset to combine into a window. Must be positive.\n      shift: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the\n        number of input elements by which the window moves in each iteration.\n        Defaults to `size`. Must be positive.\n      stride: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the\n        stride of the input elements in the sliding window. Must be positive.\n        The default value of 1 means \"retain every input element\".\n      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\n        whether the last window should be dropped if its size is smaller than\n        `size`.\n\n    Returns:\n      Dataset: A `Dataset` of (nests of) windows -- a finite datasets of flat\n        elements created from the (nests of) input elements.\n\n    \"\"\"\n    if shift is None:\n      shift = size\n    return WindowDataset(self, size, shift, stride, drop_remainder)\n\n  def reduce(self, initial_state, reduce_func):\n    \"\"\"Reduces the input dataset to a single element.\n\n    The transformation calls `reduce_func` successively on every element of\n    the input dataset until the dataset is exhausted, aggregating information in\n    its internal state. The `initial_state` argument is used for the initial\n    state and the final state is returned as the result.\n\n    >>> tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, _: x + 1).numpy()\n    5\n    >>> tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, y: x + y).numpy()\n    10\n\n    Args:\n      initial_state: An element representing the initial state of the\n        transformation.\n      reduce_func: A function that maps `(old_state, input_element)` to\n        `new_state`. It must take two arguments and return a new element\n        The structure of `new_state` must match the structure of\n        `initial_state`.\n\n    Returns:\n      A dataset element corresponding to the final state of the transformation.\n\n    \"\"\"\n\n    with ops.name_scope(\"initial_state\"):\n      initial_state = structure.normalize_element(initial_state)\n    state_structure = structure.type_spec_from_value(initial_state)\n\n    # Iteratively rerun the reduce function until reaching a fixed point on\n    # `state_structure`.\n    need_to_rerun = True\n    while need_to_rerun:\n\n      wrapped_func = StructuredFunctionWrapper(\n          reduce_func,\n          \"reduce()\",\n          input_structure=(state_structure, self.element_spec),\n          add_to_graph=False)\n\n      # Extract and validate class information from the returned values.\n      output_classes = wrapped_func.output_classes\n      state_classes = nest.map_structure(\n          lambda component_spec: component_spec._to_legacy_output_classes(),  # pylint: disable=protected-access\n          state_structure)\n      for new_state_class, state_class in zip(\n          nest.flatten(output_classes), nest.flatten(state_classes)):\n        if not issubclass(new_state_class, state_class):\n          raise TypeError(\n              \"The element classes for the new state must match the initial \"\n              \"state. Expected %s; got %s.\" %\n              (state_classes, wrapped_func.output_classes))\n\n      # Extract and validate type information from the returned values.\n      output_types = wrapped_func.output_types\n      state_types = nest.map_structure(\n          lambda component_spec: component_spec._to_legacy_output_types(),  # pylint: disable=protected-access\n          state_structure)\n      for new_state_type, state_type in zip(\n          nest.flatten(output_types), nest.flatten(state_types)):\n        if new_state_type != state_type:\n          raise TypeError(\n              \"The element types for the new state must match the initial \"\n              \"state. Expected %s; got %s.\" %\n              (state_types, wrapped_func.output_types))\n\n      # Extract shape information from the returned values.\n      output_shapes = wrapped_func.output_shapes\n      state_shapes = nest.map_structure(\n          lambda component_spec: component_spec._to_legacy_output_shapes(),  # pylint: disable=protected-access\n          state_structure)\n      flat_state_shapes = nest.flatten(state_shapes)\n      flat_new_state_shapes = nest.flatten(output_shapes)\n      weakened_state_shapes = [\n          original.most_specific_compatible_shape(new)\n          for original, new in zip(flat_state_shapes, flat_new_state_shapes)\n      ]\n\n      need_to_rerun = False\n      for original_shape, weakened_shape in zip(flat_state_shapes,\n                                                weakened_state_shapes):\n        if original_shape.ndims is not None and (\n            weakened_shape.ndims is None or\n            original_shape.as_list() != weakened_shape.as_list()):\n          need_to_rerun = True\n          break\n\n      if need_to_rerun:\n        # TODO(b/110122868): Support a \"most specific compatible structure\"\n        # method for combining structures, to avoid using legacy structures\n        # here.\n        state_structure = structure.convert_legacy_structure(\n            state_types,\n            nest.pack_sequence_as(state_shapes, weakened_state_shapes),\n            state_classes)\n\n    reduce_func = wrapped_func.function\n    reduce_func.add_to_graph(ops.get_default_graph())\n\n    dataset = self._apply_options()\n\n    # pylint: disable=protected-access\n    return structure.from_compatible_tensor_list(\n        state_structure,\n        gen_dataset_ops.reduce_dataset(\n            dataset._variant_tensor,\n            structure.to_tensor_list(state_structure, initial_state),\n            reduce_func.captured_inputs,\n            f=reduce_func,\n            output_shapes=structure.get_flat_tensor_shapes(state_structure),\n            output_types=structure.get_flat_tensor_types(state_structure)))\n\n  def unbatch(self):\n    \"\"\"Splits elements of a dataset into multiple elements.\n\n    For example, if elements of the dataset are shaped `[B, a0, a1, ...]`,\n    where `B` may vary for each input element, then for each element in the\n    dataset, the unbatched dataset will contain `B` consecutive elements\n    of shape `[a0, a1, ...]`.\n\n    >>> elements = [ [1, 2, 3], [1, 2], [1, 2, 3, 4] ]\n    >>> dataset = tf.data.Dataset.from_generator(lambda: elements, tf.int64)\n    >>> dataset = dataset.unbatch()\n    >>> list(dataset.as_numpy_iterator())\n    [1, 2, 3, 1, 2, 1, 2, 3, 4]\n\n    Returns:\n      A `Dataset`.\n    \"\"\"\n    normalized_dataset = normalize_to_dense(self)\n    return _UnbatchDataset(normalized_dataset)\n\n  def with_options(self, options):\n    \"\"\"Returns a new `tf.data.Dataset` with the given options set.\n\n    The options are \"global\" in the sense they apply to the entire dataset.\n    If options are set multiple times, they are merged as long as different\n    options do not use different non-default values.\n\n    >>> ds = tf.data.Dataset.range(5)\n    >>> ds = ds.interleave(lambda x: tf.data.Dataset.range(5),\n    ...                    cycle_length=3,\n    ...                    num_parallel_calls=3)\n    >>> options = tf.data.Options()\n    >>> # This will make the interleave order non-deterministic.\n    >>> options.experimental_deterministic = False\n    >>> ds = ds.with_options(options)\n\n    Args:\n      options: A `tf.data.Options` that identifies the options the use.\n\n    Returns:\n      Dataset: A `Dataset` with the given options.\n\n    Raises:\n      ValueError: when an option is set more than once to a non-default value\n    \"\"\"\n    return _OptionsDataset(self, options)\n\n\n@tf_export(v1=[\"data.Dataset\"])\nclass DatasetV1(DatasetV2):\n  \"\"\"Represents a potentially large set of elements.\n\n  A `Dataset` can be used to represent an input pipeline as a\n  collection of elements and a \"logical plan\" of transformations that act on\n  those elements.\n  \"\"\"\n\n  def __init__(self):\n    try:\n      variant_tensor = self._as_variant_tensor()\n    except AttributeError as e:\n      if \"_as_variant_tensor\" in str(e):\n        raise AttributeError(\"Please use _variant_tensor instead of \"\n                             \"_as_variant_tensor() to obtain the variant \"\n                             \"associated with a dataset\")\n      raise AttributeError(\"{}: A likely cause of this error is that the super \"\n                           \"call for this dataset is not the last line of the \"\n                           \"__init__ method. The base class causes the \"\n                           \"_as_variant_tensor call in its constructor and \"\n                           \"if that uses attributes defined in the __init__ \"\n                           \"method, those attrs need to be defined before the \"\n                           \"super call.\".format(e))\n    super(DatasetV1, self).__init__(variant_tensor)\n\n  @abc.abstractmethod\n  def _as_variant_tensor(self):\n    \"\"\"Creates a scalar `tf.Tensor` of `tf.variant` representing this dataset.\n\n    Returns:\n      A scalar `tf.Tensor` of `tf.variant` type, which represents this dataset.\n    \"\"\"\n    raise NotImplementedError(\"Dataset._as_variant_tensor\")\n\n  @deprecation.deprecated(\n      None, \"Use `for ... in dataset:` to iterate over a dataset. If using \"\n      \"`tf.estimator`, return the `Dataset` object directly from your input \"\n      \"function. As a last resort, you can use \"\n      \"`tf.compat.v1.data.make_one_shot_iterator(dataset)`.\")\n  def make_one_shot_iterator(self):\n    \"\"\"Creates an `Iterator` for enumerating the elements of this dataset.\n\n    Note: The returned iterator will be initialized automatically.\n    A \"one-shot\" iterator does not currently support re-initialization.\n\n    Returns:\n      An `Iterator` over the elements of this dataset.\n    \"\"\"\n    return self._make_one_shot_iterator()\n\n  def _make_one_shot_iterator(self):  # pylint: disable=missing-docstring\n    if context.executing_eagerly():\n      return iterator_ops.OwnedIterator(self)\n\n    _ensure_same_dataset_graph(self)\n    # Now that we create datasets at python object creation time, the capture\n    # by value _make_dataset() function would try to capture these variant\n    # tensor dataset inputs, which are marked as stateful ops and would throw\n    # an error if we try and capture them. We therefore traverse the graph\n    # to find all these ops and whitelist them so that the capturing\n    # logic instead of throwing an error recreates these ops which is what was\n    # happening before.\n    all_ds_ops = traverse.obtain_all_variant_tensor_ops(self)\n    graph_level_seed, op_level_seed = core_random_seed.get_seed(None)\n\n    # NOTE(mrry): We capture by value here to ensure that `_make_dataset()` is\n    # a 0-argument function.\n    @function.Defun(capture_by_value=True, whitelisted_stateful_ops=all_ds_ops)\n    def _make_dataset():\n      \"\"\"Factory function for a dataset.\"\"\"\n      # NOTE(mrry): `Defun` does not capture the graph-level seed from the\n      # enclosing graph, so if a graph-level seed is present we set the local\n      # graph seed based on a combination of the graph- and op-level seeds.\n      if graph_level_seed is not None:\n        assert op_level_seed is not None\n        core_random_seed.set_random_seed(\n            (graph_level_seed + 87654321 * op_level_seed) % (2 ** 63 - 1))\n\n      dataset = self._apply_options()\n      return dataset._variant_tensor  # pylint: disable=protected-access\n\n    try:\n      _make_dataset.add_to_graph(ops.get_default_graph())\n    except ValueError as err:\n      if \"Cannot capture a stateful node\" in str(err):\n        raise ValueError(\n            \"Failed to create a one-shot iterator for a dataset. \"\n            \"`Dataset.make_one_shot_iterator()` does not support datasets that \"\n            \"capture stateful objects, such as a `Variable` or `LookupTable`. \"\n            \"In these cases, use `Dataset.make_initializable_iterator()`. \"\n            \"(Original error: %s)\" % err)\n      else:\n        six.reraise(ValueError, err)\n\n    # pylint: disable=protected-access\n    return iterator_ops.Iterator(\n        gen_dataset_ops.one_shot_iterator(\n            dataset_factory=_make_dataset, **self._flat_structure), None,\n        get_legacy_output_types(self), get_legacy_output_shapes(self),\n        get_legacy_output_classes(self))\n\n  @deprecation.deprecated(\n      None, \"Use `for ... in dataset:` to iterate over a dataset. If using \"\n      \"`tf.estimator`, return the `Dataset` object directly from your input \"\n      \"function. As a last resort, you can use \"\n      \"`tf.compat.v1.data.make_initializable_iterator(dataset)`.\")\n  def make_initializable_iterator(self, shared_name=None):\n    \"\"\"Creates an `Iterator` for enumerating the elements of this dataset.\n\n    Note: The returned iterator will be in an uninitialized state,\n    and you must run the `iterator.initializer` operation before using it:\n\n    ```python\n    dataset = ...\n    iterator = dataset.make_initializable_iterator()\n    # ...\n    sess.run(iterator.initializer)\n    ```\n\n    Args:\n      shared_name: (Optional.) If non-empty, the returned iterator will be\n        shared under the given name across multiple sessions that share the same\n        devices (e.g. when using a remote server).\n\n    Returns:\n      An `Iterator` over the elements of this dataset.\n\n    Raises:\n      RuntimeError: If eager execution is enabled.\n    \"\"\"\n\n    return self._make_initializable_iterator(shared_name)\n\n  def _make_initializable_iterator(self, shared_name=None):  # pylint: disable=missing-docstring\n    if context.executing_eagerly():\n      raise RuntimeError(\n          \"dataset.make_initializable_iterator is not supported when eager \"\n          \"execution is enabled. Use `for element in dataset` instead.\")\n    _ensure_same_dataset_graph(self)\n    dataset = self._apply_options()\n    if shared_name is None:\n      shared_name = \"\"\n    iterator_resource = gen_dataset_ops.iterator_v2(\n        container=\"\", shared_name=shared_name, **self._flat_structure)\n    with ops.colocate_with(iterator_resource):\n      initializer = gen_dataset_ops.make_iterator(\n          dataset._variant_tensor,  # pylint: disable=protected-access\n          iterator_resource)\n    # pylint: disable=protected-access\n    return iterator_ops.Iterator(\n        iterator_resource, initializer, get_legacy_output_types(dataset),\n        get_legacy_output_shapes(dataset), get_legacy_output_classes(dataset))\n\n  @property\n  @deprecation.deprecated(\n      None, \"Use `tf.compat.v1.data.get_output_classes(dataset)`.\")\n  def output_classes(self):\n    \"\"\"Returns the class of each component of an element of this dataset.\n\n    Returns:\n      A nested structure of Python `type` objects corresponding to each\n      component of an element of this dataset.\n    \"\"\"\n    return nest.map_structure(\n        lambda component_spec: component_spec._to_legacy_output_classes(),  # pylint: disable=protected-access\n        self.element_spec)\n\n  @property\n  @deprecation.deprecated(\n      None, \"Use `tf.compat.v1.data.get_output_shapes(dataset)`.\")\n  def output_shapes(self):\n    \"\"\"Returns the shape of each component of an element of this dataset.\n\n    Returns:\n      A nested structure of `tf.TensorShape` objects corresponding to each\n      component of an element of this dataset.\n    \"\"\"\n    return nest.map_structure(\n        lambda component_spec: component_spec._to_legacy_output_shapes(),  # pylint: disable=protected-access\n        self.element_spec)\n\n  @property\n  @deprecation.deprecated(\n      None, \"Use `tf.compat.v1.data.get_output_types(dataset)`.\")\n  def output_types(self):\n    \"\"\"Returns the type of each component of an element of this dataset.\n\n    Returns:\n      A nested structure of `tf.DType` objects corresponding to each component\n      of an element of this dataset.\n    \"\"\"\n    return nest.map_structure(\n        lambda component_spec: component_spec._to_legacy_output_types(),  # pylint: disable=protected-access\n        self.element_spec)\n\n  @property\n  def element_spec(self):\n    # TODO(b/110122868): Remove this override once all `Dataset` instances\n    # implement `element_structure`.\n    return structure.convert_legacy_structure(\n        self.output_types, self.output_shapes, self.output_classes)\n\n  @staticmethod\n  @functools.wraps(DatasetV2.from_tensors)\n  def from_tensors(tensors):\n    return DatasetV1Adapter(DatasetV2.from_tensors(tensors))\n\n  @staticmethod\n  @functools.wraps(DatasetV2.from_tensor_slices)\n  def from_tensor_slices(tensors):\n    return DatasetV1Adapter(DatasetV2.from_tensor_slices(tensors))\n\n  @staticmethod\n  @deprecation.deprecated(None, \"Use `tf.data.Dataset.from_tensor_slices()`.\")\n  def from_sparse_tensor_slices(sparse_tensor):\n    \"\"\"Splits each rank-N `tf.SparseTensor` in this dataset row-wise.\n\n    Args:\n      sparse_tensor: A `tf.SparseTensor`.\n\n    Returns:\n      Dataset: A `Dataset` of rank-(N-1) sparse tensors.\n    \"\"\"\n    return DatasetV1Adapter(SparseTensorSliceDataset(sparse_tensor))\n\n  @staticmethod\n  @functools.wraps(DatasetV2.from_generator)\n  def from_generator(generator, output_types, output_shapes=None, args=None):\n    return DatasetV1Adapter(DatasetV2.from_generator(\n        generator, output_types, output_shapes, args))\n\n  @staticmethod\n  @functools.wraps(DatasetV2.range)\n  def range(*args, **kwargs):\n    return DatasetV1Adapter(DatasetV2.range(*args, **kwargs))\n\n  @staticmethod\n  @functools.wraps(DatasetV2.zip)\n  def zip(datasets):\n    return DatasetV1Adapter(DatasetV2.zip(datasets))\n\n  @functools.wraps(DatasetV2.concatenate)\n  def concatenate(self, dataset):\n    return DatasetV1Adapter(super(DatasetV1, self).concatenate(dataset))\n\n  @functools.wraps(DatasetV2.prefetch)\n  def prefetch(self, buffer_size):\n    return DatasetV1Adapter(super(DatasetV1, self).prefetch(buffer_size))\n\n  @staticmethod\n  @functools.wraps(DatasetV2.list_files)\n  def list_files(file_pattern, shuffle=None, seed=None):\n    return DatasetV1Adapter(DatasetV2.list_files(file_pattern, shuffle, seed))\n\n  @functools.wraps(DatasetV2.repeat)\n  def repeat(self, count=None):\n    return DatasetV1Adapter(super(DatasetV1, self).repeat(count))\n\n  @functools.wraps(DatasetV2.shuffle)\n  def shuffle(self, buffer_size, seed=None, reshuffle_each_iteration=None):\n    return DatasetV1Adapter(super(DatasetV1, self).shuffle(\n        buffer_size, seed, reshuffle_each_iteration))\n\n  @functools.wraps(DatasetV2.cache)\n  def cache(self, filename=\"\"):\n    return DatasetV1Adapter(super(DatasetV1, self).cache(filename))\n\n  @functools.wraps(DatasetV2.take)\n  def take(self, count):\n    return DatasetV1Adapter(super(DatasetV1, self).take(count))\n\n  @functools.wraps(DatasetV2.skip)\n  def skip(self, count):\n    return DatasetV1Adapter(super(DatasetV1, self).skip(count))\n\n  @functools.wraps(DatasetV2.shard)\n  def shard(self, num_shards, index):\n    return DatasetV1Adapter(super(DatasetV1, self).shard(num_shards, index))\n\n  @functools.wraps(DatasetV2.batch)\n  def batch(self, batch_size, drop_remainder=False):\n    return DatasetV1Adapter(super(DatasetV1, self).batch(\n        batch_size, drop_remainder))\n\n  @functools.wraps(DatasetV2.padded_batch)\n  def padded_batch(self,\n                   batch_size,\n                   padded_shapes=None,\n                   padding_values=None,\n                   drop_remainder=False):\n    return DatasetV1Adapter(\n        super(DatasetV1, self).padded_batch(batch_size, padded_shapes,\n                                            padding_values, drop_remainder))\n\n  @functools.wraps(DatasetV2.map)\n  def map(self, map_func, num_parallel_calls=None, deterministic=None):\n    if num_parallel_calls is None:\n      return DatasetV1Adapter(\n          MapDataset(self, map_func, preserve_cardinality=False))\n    else:\n      return DatasetV1Adapter(\n          ParallelMapDataset(\n              self,\n              map_func,\n              num_parallel_calls,\n              deterministic,\n              preserve_cardinality=False))\n\n  @deprecation.deprecated(None, \"Use `tf.data.Dataset.map()\")\n  def map_with_legacy_function(self,\n                               map_func,\n                               num_parallel_calls=None,\n                               deterministic=None):\n    \"\"\"Maps `map_func` across the elements of this dataset.\n\n    Note: This is an escape hatch for existing uses of `map` that do not work\n    with V2 functions. New uses are strongly discouraged and existing uses\n    should migrate to `map` as this method will be removed in V2.\n\n    Args:\n      map_func: A function mapping a nested structure of tensors (having shapes\n        and types defined by `self.output_shapes` and `self.output_types`) to\n        another nested structure of tensors.\n      num_parallel_calls: (Optional.) A `tf.int32` scalar `tf.Tensor`,\n        representing the number elements to process asynchronously in parallel.\n        If not specified, elements will be processed sequentially. If the value\n        `tf.data.experimental.AUTOTUNE` is used, then the number of parallel\n        calls is set dynamically based on available CPU.\n      deterministic: (Optional.) A boolean controlling whether determinism\n        should be traded for performance by allowing elements to be produced out\n        of order.  If `deterministic` is `None`, the\n        `tf.data.Options.experimental_deterministic` dataset option (`True` by\n        default) is used to decide whether to produce elements\n        deterministically.\n\n    Returns:\n      Dataset: A `Dataset`.\n    \"\"\"\n    if num_parallel_calls is None:\n      return DatasetV1Adapter(\n          MapDataset(\n              self,\n              map_func,\n              preserve_cardinality=False,\n              use_legacy_function=True))\n    else:\n      return DatasetV1Adapter(\n          ParallelMapDataset(\n              self,\n              map_func,\n              num_parallel_calls,\n              deterministic,\n              preserve_cardinality=False,\n              use_legacy_function=True))\n\n  @functools.wraps(DatasetV2.flat_map)\n  def flat_map(self, map_func):\n    return DatasetV1Adapter(super(DatasetV1, self).flat_map(map_func))\n\n  @functools.wraps(DatasetV2.interleave)\n  def interleave(self,\n                 map_func,\n                 cycle_length=AUTOTUNE,\n                 block_length=1,\n                 num_parallel_calls=None,\n                 deterministic=None):\n    return DatasetV1Adapter(\n        super(DatasetV1, self).interleave(map_func, cycle_length, block_length,\n                                          num_parallel_calls, deterministic))\n\n  @functools.wraps(DatasetV2.filter)\n  def filter(self, predicate):\n    return DatasetV1Adapter(super(DatasetV1, self).filter(predicate))\n\n  @deprecation.deprecated(None, \"Use `tf.data.Dataset.filter()\")\n  def filter_with_legacy_function(self, predicate):\n    \"\"\"Filters this dataset according to `predicate`.\n\n    Note: This is an escape hatch for existing uses of `filter` that do not work\n    with V2 functions. New uses are strongly discouraged and existing uses\n    should migrate to `filter` as this method will be removed in V2.\n\n    Args:\n      predicate: A function mapping a nested structure of tensors (having shapes\n        and types defined by `self.output_shapes` and `self.output_types`) to a\n        scalar `tf.bool` tensor.\n\n    Returns:\n      Dataset: The `Dataset` containing the elements of this dataset for which\n          `predicate` is `True`.\n    \"\"\"\n    return FilterDataset(self, predicate, use_legacy_function=True)\n\n  @functools.wraps(DatasetV2.apply)\n  def apply(self, transformation_func):\n    return DatasetV1Adapter(super(DatasetV1, self).apply(transformation_func))\n\n  @functools.wraps(DatasetV2.window)\n  def window(self, size, shift=None, stride=1, drop_remainder=False):\n    return DatasetV1Adapter(super(DatasetV1, self).window(\n        size, shift, stride, drop_remainder))\n\n  @functools.wraps(DatasetV2.unbatch)\n  def unbatch(self):\n    return DatasetV1Adapter(super(DatasetV1, self).unbatch())\n\n  @functools.wraps(DatasetV2.with_options)\n  def with_options(self, options):\n    return DatasetV1Adapter(super(DatasetV1, self).with_options(options))\n\n\nif tf2.enabled():\n  Dataset = DatasetV2\nelse:\n  Dataset = DatasetV1\n\n\nclass DatasetV1Adapter(DatasetV1):\n  \"\"\"Wraps a V2 `Dataset` object in the `tf.compat.v1.data.Dataset` API.\"\"\"\n\n  def __init__(self, dataset):\n    self._dataset = dataset\n    super(DatasetV1Adapter, self).__init__()\n\n  def _as_variant_tensor(self):\n    return self._dataset._variant_tensor  # pylint: disable=protected-access\n\n  def _has_captured_ref(self):\n    return self._dataset._has_captured_ref()  # pylint: disable=protected-access\n\n  def _inputs(self):\n    return self._dataset._inputs()  # pylint: disable=protected-access\n\n  def _functions(self):\n    return self._dataset._functions()  # pylint: disable=protected-access\n\n  def options(self):\n    return self._dataset.options()\n\n  @property\n  def element_spec(self):\n    return self._dataset.element_spec  # pylint: disable=protected-access\n\n  def __iter__(self):\n    return iter(self._dataset)\n\n\ndef _ensure_same_dataset_graph(dataset):\n  \"\"\"Walks the dataset graph to ensure all datasets come from the same graph.\"\"\"\n  # pylint: disable=protected-access\n  current_graph = ops.get_default_graph()\n  bfs_q = Queue.Queue()\n  bfs_q.put(dataset)\n  visited = []\n  while not bfs_q.empty():\n    ds = bfs_q.get()\n    visited.append(ds)\n    ds_graph = ds._graph\n    if current_graph != ds_graph:\n      raise ValueError(\n          \"The graph (\" + str(current_graph) + \") of the iterator is different \"\n          \"from the graph (\" + str(ds_graph) + \") the dataset: \" +\n          str(ds._variant_tensor) + \" was  created in. If you are using the \"\n          \"Estimator API, make sure that no part of the dataset returned by \"\n          \"the `input_fn` function is defined outside the `input_fn` function. \"\n          \"Please ensure that all datasets in the pipeline are created in the \"\n          \"same graph as the iterator.\")\n    for input_ds in ds._inputs():\n      if input_ds not in visited:\n        bfs_q.put(input_ds)\n\n\n@tf_export(v1=[\"data.make_one_shot_iterator\"])\ndef make_one_shot_iterator(dataset):\n  \"\"\"Creates a `tf.compat.v1.data.Iterator` for enumerating dataset elements.\n\n  Note: The returned iterator will be initialized automatically.\n  A \"one-shot\" iterator does not support re-initialization.\n\n  Args:\n    dataset: A `tf.data.Dataset`.\n\n  Returns:\n    A `tf.compat.v1.data.Iterator` over the elements of this dataset.\n  \"\"\"\n  try:\n    # Call the defined `_make_one_shot_iterator()` if there is one, because some\n    # datasets (e.g. for prefetching) override its behavior.\n    return dataset._make_one_shot_iterator()  # pylint: disable=protected-access\n  except AttributeError:\n    return DatasetV1Adapter(dataset)._make_one_shot_iterator()  # pylint: disable=protected-access\n\n\n@tf_export(v1=[\"data.make_initializable_iterator\"])\ndef make_initializable_iterator(dataset, shared_name=None):\n  \"\"\"Creates a `tf.compat.v1.data.Iterator` for enumerating the elements of a dataset.\n\n  Note: The returned iterator will be in an uninitialized state,\n  and you must run the `iterator.initializer` operation before using it:\n\n  ```python\n  dataset = ...\n  iterator = tf.compat.v1.data.make_initializable_iterator(dataset)\n  # ...\n  sess.run(iterator.initializer)\n  ```\n\n  Args:\n    dataset: A `tf.data.Dataset`.\n    shared_name: (Optional.) If non-empty, the returned iterator will be shared\n      under the given name across multiple sessions that share the same devices\n      (e.g. when using a remote server).\n\n  Returns:\n    A `tf.compat.v1.data.Iterator` over the elements of `dataset`.\n\n  Raises:\n    RuntimeError: If eager execution is enabled.\n  \"\"\"\n  try:\n    # Call the defined `_make_initializable_iterator()` if there is one, because\n    # some datasets (e.g. for prefetching) override its behavior.\n    return dataset._make_initializable_iterator(shared_name)  # pylint: disable=protected-access\n  except AttributeError:\n    return DatasetV1Adapter(dataset)._make_initializable_iterator(shared_name)  # pylint: disable=protected-access\n\n\n@tf_export(\"data.experimental.get_structure\")\ndef get_structure(dataset_or_iterator):\n  \"\"\"Returns the type specification of an element of a `Dataset` or `Iterator`.\n\n  Args:\n    dataset_or_iterator: A `tf.data.Dataset` or `tf.data.Iterator`.\n\n  Returns:\n    A nested structure of `tf.TypeSpec` objects matching the structure of an\n    element of `dataset_or_iterator` and specifying the type of individual\n    components.\n\n  Raises:\n    TypeError: If `dataset_or_iterator` is not a `Dataset` or `Iterator` object.\n  \"\"\"\n  try:\n    return dataset_or_iterator.element_spec  # pylint: disable=protected-access\n  except AttributeError:\n    raise TypeError(\"`dataset_or_iterator` must be a Dataset or Iterator \"\n                    \"object, but got %s.\" % type(dataset_or_iterator))\n\n\n@tf_export(v1=[\"data.get_output_classes\"])\ndef get_legacy_output_classes(dataset_or_iterator):\n  \"\"\"Returns the output classes of a `Dataset` or `Iterator` elements.\n\n  This utility method replaces the deprecated-in-V2\n  `tf.compat.v1.Dataset.output_classes` property.\n\n  Args:\n    dataset_or_iterator: A `tf.data.Dataset` or `tf.data.Iterator`.\n\n  Returns:\n    A nested structure of Python `type` objects matching the structure of the\n    dataset / iterator elements and specifying the class of the individual\n    components.\n  \"\"\"\n  return nest.map_structure(\n      lambda component_spec: component_spec._to_legacy_output_classes(),  # pylint: disable=protected-access\n      get_structure(dataset_or_iterator))\n\n\n@tf_export(v1=[\"data.get_output_shapes\"])\ndef get_legacy_output_shapes(dataset_or_iterator):\n  \"\"\"Returns the output shapes of a `Dataset` or `Iterator` elements.\n\n  This utility method replaces the deprecated-in-V2\n  `tf.compat.v1.Dataset.output_shapes` property.\n\n  Args:\n    dataset_or_iterator: A `tf.data.Dataset` or `tf.data.Iterator`.\n\n  Returns:\n    A nested structure of `tf.TensorShape` objects matching the structure of\n    the dataset / iterator elements and specifying the shape of the individual\n    components.\n  \"\"\"\n  return nest.map_structure(\n      lambda component_spec: component_spec._to_legacy_output_shapes(),  # pylint: disable=protected-access\n      get_structure(dataset_or_iterator))\n\n\n@tf_export(v1=[\"data.get_output_types\"])\ndef get_legacy_output_types(dataset_or_iterator):\n  \"\"\"Returns the output shapes of a `Dataset` or `Iterator` elements.\n\n  This utility method replaces the deprecated-in-V2\n  `tf.compat.v1.Dataset.output_types` property.\n\n  Args:\n    dataset_or_iterator: A `tf.data.Dataset` or `tf.data.Iterator`.\n\n  Returns:\n    A nested structure of `tf.DType` objects objects matching the structure of\n    dataset / iterator elements and specifying the shape of the individual\n    components.\n  \"\"\"\n  return nest.map_structure(\n      lambda component_spec: component_spec._to_legacy_output_types(),  # pylint: disable=protected-access\n      get_structure(dataset_or_iterator))\n\n\n@tf_export(\"data.Options\")\nclass Options(options_lib.OptionsBase):\n  \"\"\"Represents options for tf.data.Dataset.\n\n  An `Options` object can be, for instance, used to control which graph\n  optimizations to apply or whether to use performance modeling to dynamically\n  tune the parallelism of operations such as `tf.data.Dataset.map` or\n  `tf.data.Dataset.interleave`.\n\n  After constructing an `Options` object, use `dataset.with_options(options)` to\n  apply the options to a dataset.\n\n  >>> dataset = tf.data.Dataset.range(3)\n  >>> options = tf.data.Options()\n  >>> # Set options here.\n  >>> dataset = dataset.with_options(options)\n  \"\"\"\n\n  experimental_deterministic = options_lib.create_option(\n      name=\"experimental_deterministic\",\n      ty=bool,\n      docstring=\n      \"Whether the outputs need to be produced in deterministic order. If None,\"\n      \" defaults to True.\")\n\n  experimental_distribute = options_lib.create_option(\n      name=\"experimental_distribute\",\n      ty=distribute_options.DistributeOptions,\n      docstring=\n      \"The distribution strategy options associated with the dataset. See \"\n      \"`tf.data.experimental.DistributeOptions` for more details.\",\n      default_factory=distribute_options.DistributeOptions)\n\n  experimental_optimization = options_lib.create_option(\n      name=\"experimental_optimization\",\n      ty=optimization_options.OptimizationOptions,\n      docstring=\n      \"The optimization options associated with the dataset. See \"\n      \"`tf.data.experimental.OptimizationOptions` for more details.\",\n      default_factory=optimization_options.OptimizationOptions)\n\n  experimental_slack = options_lib.create_option(\n      name=\"experimental_slack\",\n      ty=bool,\n      docstring=\"Whether to introduce 'slack' in the last `prefetch` of the \"\n      \"input pipeline, if it exists. This may reduce CPU contention with \"\n      \"accelerator host-side activity at the start of a step. The slack \"\n      \"frequency is determined by the number of devices attached to this \"\n      \"input pipeline. If None, defaults to False.\")\n\n  experimental_stats = options_lib.create_option(\n      name=\"experimental_stats\",\n      ty=stats_options.StatsOptions,\n      docstring=\n      \"The statistics options associated with the dataset. See \"\n      \"`tf.data.experimental.StatsOptions` for more details.\",\n      default_factory=stats_options.StatsOptions)\n\n  experimental_threading = options_lib.create_option(\n      name=\"experimental_threading\",\n      ty=threading_options.ThreadingOptions,\n      docstring=\n      \"The threading options associated with the dataset. See \"\n      \"`tf.data.experimental.ThreadingOptions` for more details.\",\n      default_factory=threading_options.ThreadingOptions)\n\n  experimental_external_state_policy = options_lib.create_option(\n      name=\"experimental_external_state_policy\",\n      ty=distribute_options.ExternalStatePolicy,\n      docstring=\"By default, tf.data will refuse to serialize a dataset or \"\n      \"checkpoint its iterator if the dataset contains a stateful op as the \"\n      \"serialization / checkpointing won't be able to capture its state. \"\n      \"Users can -- at their own risk -- override this restriction by \"\n      \"explicitly specifying that they are fine throwing away the state \"\n      \"in these ops. There are three settings available - IGNORE: in which we\"\n      \"completely ignore any state; WARN: We warn the user that some state \"\n      \"might be thrown away; FAIL: We fail if any state is being captured.\",\n      default_factory=lambda: distribute_options.ExternalStatePolicy.WARN)\n\n  def _graph_rewrites(self):\n    \"\"\"Produces the list of enabled static graph rewrites.\"\"\"\n    result = []\n    if self.experimental_optimization is not None:\n      result.extend(self.experimental_optimization._graph_rewrites())  # pylint: disable=protected-access\n    else:\n      # Apply default options\n      result.extend(\n          optimization_options.OptimizationOptions()._graph_rewrites())  # pylint: disable=protected-access\n\n    if self.experimental_deterministic is False:\n      result.append(\"make_sloppy\")\n    if self.experimental_stats and self.experimental_stats.latency_all_edges:\n      result.append(\"latency_all_edges\")\n    if self.experimental_slack:\n      result.append(\"slack\")\n    if (self.experimental_distribute and\n        self.experimental_distribute._make_stateless):  # pylint: disable=protected-access\n      result.append(\"make_stateless\")\n    return result\n\n  def _graph_rewrite_configs(self):\n    \"\"\"Produces the list of configurations for enabled graph optimizations.\"\"\"\n    result = []\n    if self.experimental_optimization:\n      result.extend(self.experimental_optimization._graph_rewrite_configs())  # pylint: disable=protected-access\n\n    if self.experimental_slack:\n      num_devices = self.experimental_distribute.num_devices\n      if num_devices is None:\n        num_devices = 1\n      result.append(\"slack:slack_period:%d\" % num_devices)\n    return result\n\n  def _autotune_settings(self):\n    if self.experimental_optimization is not None:\n      return self.experimental_optimization._autotune_settings()  # pylint: disable=protected-access\n\n    # Return default autotune options\n    return optimization_options.OptimizationOptions()._autotune_settings()  # pylint: disable=protected-access\n\n  def merge(self, options):\n    \"\"\"Merges itself with the given `tf.data.Options`.\n\n    The given `tf.data.Options` can be merged as long as there does not exist an\n    attribute that is set to different values in `self` and `options`.\n\n    Args:\n      options: a `tf.data.Options` to merge with\n\n    Raises:\n      ValueError: if the given `tf.data.Options` cannot be merged\n\n    Returns:\n      New `tf.data.Options()` object which is the result of merging self with\n      the input `tf.data.Options`.\n    \"\"\"\n    return options_lib.merge_options(self, options)\n\n\nclass DatasetSource(DatasetV2):\n  \"\"\"Abstract class representing a dataset with no inputs.\"\"\"\n\n  def _inputs(self):\n    return []\n\n\nclass UnaryDataset(DatasetV2):\n  \"\"\"Abstract class representing a dataset with one input.\"\"\"\n\n  def __init__(self, input_dataset, variant_tensor):\n    self._input_dataset = input_dataset\n    super(UnaryDataset, self).__init__(variant_tensor)\n\n  def _inputs(self):\n    return [self._input_dataset]\n\n\nclass UnaryUnchangedStructureDataset(UnaryDataset):\n  \"\"\"Represents a unary dataset with the same input and output structure.\"\"\"\n\n  def __init__(self, input_dataset, variant_tensor):\n    self._input_dataset = input_dataset\n    super(UnaryUnchangedStructureDataset, self).__init__(\n        input_dataset, variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._input_dataset.element_spec\n\n\nclass TensorDataset(DatasetSource):\n  \"\"\"A `Dataset` with a single element.\"\"\"\n\n  def __init__(self, element):\n    \"\"\"See `Dataset.from_tensors()` for details.\"\"\"\n    element = structure.normalize_element(element)\n    self._structure = structure.type_spec_from_value(element)\n    self._tensors = structure.to_tensor_list(self._structure, element)\n\n    variant_tensor = gen_dataset_ops.tensor_dataset(\n        self._tensors,\n        output_shapes=structure.get_flat_tensor_shapes(self._structure))\n    super(TensorDataset, self).__init__(variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass TensorSliceDataset(DatasetSource):\n  \"\"\"A `Dataset` of slices from a dataset element.\"\"\"\n\n  def __init__(self, element):\n    \"\"\"See `Dataset.from_tensor_slices()` for details.\"\"\"\n    element = structure.normalize_element(element)\n    batched_spec = structure.type_spec_from_value(element)\n    self._tensors = structure.to_batched_tensor_list(batched_spec, element)\n    self._structure = nest.map_structure(\n        lambda component_spec: component_spec._unbatch(), batched_spec)  # pylint: disable=protected-access\n\n    batch_dim = tensor_shape.Dimension(tensor_shape.dimension_value(\n        self._tensors[0].get_shape()[0]))\n    for t in self._tensors[1:]:\n      batch_dim.assert_is_compatible_with(tensor_shape.Dimension(\n          tensor_shape.dimension_value(t.get_shape()[0])))\n\n    variant_tensor = gen_dataset_ops.tensor_slice_dataset(\n        self._tensors,\n        output_shapes=structure.get_flat_tensor_shapes(self._structure))\n    super(TensorSliceDataset, self).__init__(variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass SparseTensorSliceDataset(DatasetSource):\n  \"\"\"A `Dataset` that splits a rank-N `tf.SparseTensor` into its rows.\"\"\"\n\n  def __init__(self, sparse_tensor):\n    \"\"\"See `Dataset.from_sparse_tensor_slices()` for details.\"\"\"\n    if not isinstance(sparse_tensor, sparse_tensor_lib.SparseTensor):\n      raise TypeError(\n          \"`sparse_tensor` must be a `tf.SparseTensor` object. Was {}.\".format(\n              sparse_tensor))\n    self._sparse_tensor = sparse_tensor\n\n    indices_shape = self._sparse_tensor.indices.get_shape()\n    shape_shape = self._sparse_tensor.dense_shape.get_shape()\n    rank = (indices_shape.dims[1] - 1).merge_with(shape_shape.dims[0] - 1)\n    self._structure = (tensor_spec.TensorSpec([None, rank], dtypes.int64),\n                       tensor_spec.TensorSpec([None],\n                                              self._sparse_tensor.dtype),\n                       tensor_spec.TensorSpec([rank], dtypes.int64))\n\n    variant_tensor = gen_dataset_ops.sparse_tensor_slice_dataset(\n        self._sparse_tensor.indices, self._sparse_tensor.values,\n        self._sparse_tensor.dense_shape)\n    super(SparseTensorSliceDataset, self).__init__(variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass _VariantDataset(DatasetV2):\n  \"\"\"A Dataset wrapper around a `tf.variant`-typed function argument.\"\"\"\n\n  def __init__(self, dataset_variant, structure):\n    self._structure = structure\n    super(_VariantDataset, self).__init__(dataset_variant)\n\n  def _inputs(self):\n    return []\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass _NestedVariant(composite_tensor.CompositeTensor):\n\n  def __init__(self, variant_tensor, element_spec, dataset_shape):\n    self._variant_tensor = variant_tensor\n    self._element_spec = element_spec\n    self._dataset_shape = dataset_shape\n\n  @property\n  def _type_spec(self):\n    return DatasetSpec(self._element_spec, self._dataset_shape)\n\n\n@tf_export(\"data.experimental.from_variant\")\ndef from_variant(variant, structure):\n  \"\"\"Constructs a dataset from the given variant and structure.\n\n  Args:\n    variant: A scalar `tf.variant` tensor representing a dataset.\n    structure: A `tf.data.experimental.Structure` object representing the\n      structure of each element in the dataset.\n\n  Returns:\n    A `tf.data.Dataset` instance.\n  \"\"\"\n  return _VariantDataset(variant, structure)  # pylint: disable=protected-access\n\n\n@tf_export(\"data.experimental.to_variant\")\ndef to_variant(dataset):\n  \"\"\"Returns a variant representing the given dataset.\n\n  Args:\n    dataset: A `tf.data.Dataset`.\n\n  Returns:\n    A scalar `tf.variant` tensor representing the given dataset.\n  \"\"\"\n  return dataset._variant_tensor  # pylint: disable=protected-access\n\n\n@tf_export(\n    \"data.DatasetSpec\",\n    v1=[\"data.DatasetSpec\", \"data.experimental.DatasetStructure\"])\nclass DatasetSpec(type_spec.BatchableTypeSpec):\n  \"\"\"Type specification for `tf.data.Dataset`.\n\n  See `tf.TypeSpec` for more information about TensorFlow type specifications.\n\n  >>> dataset = tf.data.Dataset.range(3)\n  >>> tf.data.DatasetSpec.from_value(dataset)\n  DatasetSpec(TensorSpec(shape=(), dtype=tf.int64, name=None), TensorShape([]))\n  \"\"\"\n\n  __slots__ = [\"_element_spec\", \"_dataset_shape\"]\n\n  def __init__(self, element_spec, dataset_shape=()):\n    self._element_spec = element_spec\n    self._dataset_shape = tensor_shape.as_shape(dataset_shape)\n\n  @property\n  def value_type(self):\n    return _VariantDataset\n\n  def _serialize(self):\n    return (self._element_spec, self._dataset_shape)\n\n  @property\n  def _component_specs(self):\n    return tensor_spec.TensorSpec(self._dataset_shape, dtypes.variant)\n\n  def _to_components(self, value):\n    return value._variant_tensor  # pylint: disable=protected-access\n\n  def _from_components(self, components):\n    # pylint: disable=protected-access\n    if self._dataset_shape.ndims == 0:\n      return _VariantDataset(components, self._element_spec)\n    else:\n      return _NestedVariant(components, self._element_spec, self._dataset_shape)\n\n  def _to_tensor_list(self, value):\n    return [\n        ops.convert_to_tensor(\n            tf_nest.map_structure(lambda x: x._variant_tensor, value))  # pylint: disable=protected-access\n    ]\n\n  @staticmethod\n  def from_value(value):\n    \"\"\"Creates a `DatasetSpec` for the given `tf.data.Dataset` value.\"\"\"\n    return DatasetSpec(value.element_spec)  # pylint: disable=protected-access\n\n  def _batch(self, batch_size):\n    return DatasetSpec(\n        self._element_spec,\n        tensor_shape.TensorShape([batch_size]).concatenate(self._dataset_shape))\n\n  def _unbatch(self):\n    if self._dataset_shape.ndims == 0:\n      raise ValueError(\"Unbatching a dataset is only supported for rank >= 1\")\n    return DatasetSpec(self._element_spec, self._dataset_shape[1:])\n\n  def _to_batched_tensor_list(self, value):\n    if self._dataset_shape.ndims == 0:\n      raise ValueError(\"Unbatching a dataset is only supported for rank >= 1\")\n    return self._to_tensor_list(value)\n\n  def _to_legacy_output_types(self):\n    return self\n\n  def _to_legacy_output_shapes(self):\n    return self\n\n  def _to_legacy_output_classes(self):\n    return self\n\n\nclass StructuredFunctionWrapper(object):\n  \"\"\"A function wrapper that supports structured arguments and return values.\"\"\"\n\n  # pylint: disable=protected-access\n  def __init__(self,\n               func,\n               transformation_name,\n               dataset=None,\n               input_classes=None,\n               input_shapes=None,\n               input_types=None,\n               input_structure=None,\n               add_to_graph=True,\n               use_legacy_function=False,\n               defun_kwargs=None):\n    \"\"\"Creates a new `StructuredFunctionWrapper` for the given function.\n\n    Args:\n      func: A function from a nested structure to another nested structure.\n      transformation_name: Human-readable name of the transformation in which\n        this function is being instantiated, for error messages.\n      dataset: (Optional.) A `tf.data.Dataset`. If given, the structure of this\n        dataset will be assumed as the structure for `func` arguments; otherwise\n        `input_classes`, `input_shapes`, and `input_types` must be defined.\n      input_classes: (Optional.) A nested structure of `type`. If given, this\n        argument defines the Python types for `func` arguments.\n      input_shapes: (Optional.) A nested structure of `tf.TensorShape`. If\n        given, this argument defines the shapes and structure for `func`\n        arguments.\n      input_types: (Optional.) A nested structure of `tf.DType`. If given, this\n        argument defines the element types and structure for `func` arguments.\n      input_structure: (Optional.) A `Structure` object. If given, this argument\n        defines the element types and structure for `func` arguments.\n      add_to_graph: (Optional.) If `True`, the function will be added to the\n        default graph, if it exists.\n      use_legacy_function: (Optional.) A boolean that determines whether the\n        function be created using `tensorflow.python.eager.function.defun`\n        (default behavior) or `tensorflow.python.framework.function.Defun`\n        (legacy behavior).\n      defun_kwargs: (Optional.) A dictionary mapping string argument names to\n        values. If supplied, will be passed to `function` as keyword arguments.\n\n    Raises:\n      ValueError: If an invalid combination of `dataset`, `input_classes`,\n        `input_shapes`, and `input_types` is passed.\n    \"\"\"\n    if input_structure is None:\n      if dataset is None:\n        if input_classes is None or input_shapes is None or input_types is None:\n          raise ValueError(\"Either `dataset`, `input_structure` or all of \"\n                           \"`input_classes`, `input_shapes`, and `input_types` \"\n                           \"must be specified.\")\n        self._input_structure = structure.convert_legacy_structure(\n            input_types, input_shapes, input_classes)\n      else:\n        if not (input_classes is None and input_shapes is None and\n                input_types is None):\n          raise ValueError(\"Either `dataset`, `input_structure` or all of \"\n                           \"`input_classes`, `input_shapes`, and `input_types` \"\n                           \"must be specified.\")\n        self._input_structure = dataset.element_spec\n    else:\n      if not (dataset is None and input_classes is None and input_shapes is None\n              and input_types is None):\n        raise ValueError(\"Either `dataset`, `input_structure`, or all of \"\n                         \"`input_classes`, `input_shapes`, and `input_types` \"\n                         \"must be specified.\")\n      self._input_structure = input_structure\n\n    self._func = func\n\n    # There is no graph to add in eager mode.\n    add_to_graph &= not context.executing_eagerly()\n    # There are some lifetime issues when a legacy function is not added to a\n    # out-living graph. It's already deprecated so de-prioritizing the fix.\n    add_to_graph |= use_legacy_function\n\n    if defun_kwargs is None:\n      defun_kwargs = {}\n\n    readable_transformation_name = transformation_name.replace(\n        \".\", \"_\")[:-2] if len(transformation_name) > 2 else \"\"\n\n    func_name = \"_\".join(\n        [readable_transformation_name,\n         function_utils.get_func_name(func)])\n    # Sanitize function name to remove symbols that interfere with graph\n    # construction.\n    for symbol in [\"<\", \">\", \"\\\\\", \"'\", \" \"]:\n      func_name = func_name.replace(symbol, \"\")\n\n    ag_ctx = autograph_ctx.control_status_ctx()\n\n    def _warn_if_collections(transformation_name):\n      \"\"\"Prints a warning if the given graph uses common graph collections.\n\n      NOTE(mrry): Currently a warning is only generated for resources. Any\n      variables created will be automatically hoisted out to the outermost scope\n      using `init_scope()`. Some collections (such as for control-flow contexts)\n      are benign and should not generate a warning.\n\n      Args:\n        transformation_name: A human-readable name for the transformation.\n      \"\"\"\n      warnings.warn(\"Creating resources inside a function passed to %s \"\n                    \"is not supported. Create each resource outside the \"\n                    \"function, and capture it inside the function to use it.\" %\n                    transformation_name, stacklevel=5)\n\n    def _wrapper_helper(*args):\n      \"\"\"Wrapper for passing nested structures to and from tf.data functions.\"\"\"\n      nested_args = structure.from_compatible_tensor_list(\n          self._input_structure, args)\n      if not _should_unpack_args(nested_args):\n        nested_args = (nested_args,)\n\n      ret = autograph.tf_convert(func, ag_ctx)(*nested_args)\n      # If `func` returns a list of tensors, `nest.flatten()` and\n      # `ops.convert_to_tensor()` would conspire to attempt to stack\n      # those tensors into a single tensor, because the customized\n      # version of `nest.flatten()` does not recurse into lists. Since\n      # it is more likely that the list arose from returning the\n      # result of an operation (such as `tf.numpy_function()`) that returns a\n      # list of not-necessarily-stackable tensors, we treat the\n      # returned value is a `tuple` instead. A user wishing to pack\n      # the return value into a single tensor can use an explicit\n      # `tf.stack()` before returning.\n      if isinstance(ret, list):\n        ret = tuple(ret)\n\n      try:\n        self._output_structure = structure.type_spec_from_value(ret)\n      except (ValueError, TypeError):\n        six.reraise(\n            TypeError,\n            TypeError(\"Unsupported return value from function passed to \"\n                      \"%s: %s.\" % (transformation_name, ret)),\n            sys.exc_info()[2])\n      return ret\n\n    if use_legacy_function:\n      func_name = func_name + \"_\" + str(ops.uid())\n\n      @function.Defun(\n          *structure.get_flat_tensor_types(self._input_structure),\n          func_name=func_name,\n          **defun_kwargs)\n      def wrapper_fn(*args):\n        ret = _wrapper_helper(*args)\n        # _warn_if_collections(transformation_name, ops.get_default_graph(), 0)\n        return structure.to_tensor_list(self._output_structure, ret)\n\n      self._function = wrapper_fn\n      resource_tracker = tracking.ResourceTracker()\n      with tracking.resource_tracker_scope(resource_tracker):\n        if add_to_graph:\n          self._function.add_to_graph(ops.get_default_graph())\n        else:\n          # Use the private method that will execute `wrapper_fn` but delay\n          # adding it to the graph in case (e.g.) we need to rerun the function.\n          self._function._create_definition_if_needed()\n      if resource_tracker.resources:\n        _warn_if_collections(transformation_name)\n\n    else:\n      defun_kwargs.update({\"func_name\": func_name})\n\n      # Note: _wrapper_helper will apply autograph based on context.\n      @eager_function.defun_with_attributes(\n          input_signature=structure.get_flat_tensor_specs(\n              self._input_structure),\n          autograph=False,\n          attributes=defun_kwargs)\n      def wrapper_fn(*args):  # pylint: disable=missing-docstring\n        ret = _wrapper_helper(*args)\n        ret = structure.to_tensor_list(self._output_structure, ret)\n        return [ops.convert_to_tensor(t) for t in ret]\n\n      resource_tracker = tracking.ResourceTracker()\n      with tracking.resource_tracker_scope(resource_tracker):\n        # TODO(b/141462134): Switch to using garbage collection.\n        self._function = wrapper_fn.get_concrete_function()\n\n        if add_to_graph:\n          self._function.add_to_graph(ops.get_default_graph())\n      if resource_tracker.resources:\n        _warn_if_collections(transformation_name)\n\n      outer_graph_seed = ops.get_default_graph().seed\n      if outer_graph_seed and self._function.graph.seed == outer_graph_seed:\n        if self._function.graph._seed_used:\n          warnings.warn(\n              \"Seed %s from outer graph might be getting used by function %s, \"\n              \"if the random op has not been provided any seed. Explicitly set \"\n              \"the seed in the function if this is not the intended behavior.\"\n              %(outer_graph_seed, func_name), stacklevel=4)\n  # pylint: enable=protected-access\n\n  @property\n  def output_structure(self):\n    return self._output_structure\n\n  @property\n  def output_classes(self):\n    return nest.map_structure(\n        lambda component_spec: component_spec._to_legacy_output_classes(),  # pylint: disable=protected-access\n        self._output_structure)\n\n  @property\n  def output_shapes(self):\n    return nest.map_structure(\n        lambda component_spec: component_spec._to_legacy_output_shapes(),  # pylint: disable=protected-access\n        self._output_structure)\n\n  @property\n  def output_types(self):\n    return nest.map_structure(\n        lambda component_spec: component_spec._to_legacy_output_types(),  # pylint: disable=protected-access\n        self._output_structure)\n\n  @property\n  def function(self):\n    return self._function\n\n\nclass _GeneratorDataset(DatasetSource):\n  \"\"\"A `Dataset` that generates elements by invoking a function.\"\"\"\n\n  def __init__(self, init_args, init_func, next_func, finalize_func):\n    \"\"\"Constructs a `_GeneratorDataset`.\n\n    Args:\n      init_args: A nested structure representing the arguments to `init_func`.\n      init_func: A TensorFlow function that will be called on `init_args` each\n        time a C++ iterator over this dataset is constructed. Returns a nested\n        structure representing the \"state\" of the dataset.\n      next_func: A TensorFlow function that will be called on the result of\n        `init_func` to produce each element, and that raises `OutOfRangeError`\n        to terminate iteration.\n      finalize_func: A TensorFlow function that will be called on the result of\n        `init_func` immediately before a C++ iterator over this dataset is\n        destroyed. The return value is ignored.\n    \"\"\"\n    self._init_args = init_args\n\n    self._init_structure = structure.type_spec_from_value(init_args)\n\n    self._init_func = StructuredFunctionWrapper(\n        init_func,\n        self._transformation_name(),\n        input_structure=self._init_structure)\n\n    self._next_func = StructuredFunctionWrapper(\n        next_func,\n        self._transformation_name(),\n        input_structure=self._init_func.output_structure)\n\n    self._finalize_func = StructuredFunctionWrapper(\n        finalize_func,\n        self._transformation_name(),\n        input_structure=self._init_func.output_structure)\n    variant_tensor = gen_dataset_ops.generator_dataset(\n        structure.to_tensor_list(self._init_structure, self._init_args) +\n        self._init_func.function.captured_inputs,\n        self._next_func.function.captured_inputs,\n        self._finalize_func.function.captured_inputs,\n        init_func=self._init_func.function,\n        next_func=self._next_func.function,\n        finalize_func=self._finalize_func.function,\n        **self._flat_structure)\n    super(_GeneratorDataset, self).__init__(variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._next_func.output_structure\n\n  def _transformation_name(self):\n    return \"Dataset.from_generator()\"\n\n\nclass ZipDataset(DatasetV2):\n  \"\"\"A `Dataset` that zips its inputs together.\"\"\"\n\n  def __init__(self, datasets):\n    \"\"\"See `Dataset.zip()` for details.\"\"\"\n    for ds in nest.flatten(datasets):\n      if not isinstance(ds, DatasetV2):\n        if isinstance(ds, list):\n          message = (\"The argument to `Dataset.zip()` must be a nested \"\n                     \"structure of `Dataset` objects. Nested structures do not \"\n                     \"support Python lists; please use a tuple instead.\")\n        else:\n          message = (\"The argument to `Dataset.zip()` must be a nested \"\n                     \"structure of `Dataset` objects.\")\n        raise TypeError(message)\n    self._datasets = datasets\n    self._structure = nest.pack_sequence_as(\n        self._datasets,\n        [ds.element_spec for ds in nest.flatten(self._datasets)])\n    variant_tensor = gen_dataset_ops.zip_dataset(\n        [ds._variant_tensor for ds in nest.flatten(self._datasets)],\n        **self._flat_structure)\n    super(ZipDataset, self).__init__(variant_tensor)\n\n  def _inputs(self):\n    return nest.flatten(self._datasets)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass ConcatenateDataset(DatasetV2):\n  \"\"\"A `Dataset` that concatenates its input with given dataset.\"\"\"\n\n  def __init__(self, input_dataset, dataset_to_concatenate):\n    \"\"\"See `Dataset.concatenate()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._dataset_to_concatenate = dataset_to_concatenate\n\n    output_types = get_legacy_output_types(input_dataset)\n    if output_types != get_legacy_output_types(dataset_to_concatenate):\n      raise TypeError(\n          \"Two datasets to concatenate have different types %s and %s\" %\n          (output_types, get_legacy_output_types(dataset_to_concatenate)))\n\n    output_classes = get_legacy_output_classes(input_dataset)\n    if output_classes != get_legacy_output_classes(dataset_to_concatenate):\n      raise TypeError(\n          \"Two datasets to concatenate have different classes %s and %s\" %\n          (output_classes, get_legacy_output_classes(dataset_to_concatenate)))\n\n    input_shapes = get_legacy_output_shapes(self._input_dataset)\n    output_shapes = nest.pack_sequence_as(input_shapes, [\n        ts1.most_specific_compatible_shape(ts2)\n        for (ts1, ts2) in zip(\n            nest.flatten(input_shapes),\n            nest.flatten(get_legacy_output_shapes(\n                self._dataset_to_concatenate)))\n    ])\n\n    self._structure = structure.convert_legacy_structure(\n        output_types, output_shapes, output_classes)\n\n    self._input_datasets = [input_dataset, dataset_to_concatenate]\n    # pylint: disable=protected-access\n    variant_tensor = gen_dataset_ops.concatenate_dataset(\n        input_dataset._variant_tensor, dataset_to_concatenate._variant_tensor,\n        **self._flat_structure)\n    # pylint: enable=protected-access\n    super(ConcatenateDataset, self).__init__(variant_tensor)\n\n  def _inputs(self):\n    return self._input_datasets\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass RepeatDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that repeats its input several times.\"\"\"\n\n  def __init__(self, input_dataset, count):\n    \"\"\"See `Dataset.repeat()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    if count is None:\n      self._count = constant_op.constant(-1, dtype=dtypes.int64, name=\"count\")\n    else:\n      self._count = ops.convert_to_tensor(\n          count, dtype=dtypes.int64, name=\"count\")\n    variant_tensor = gen_dataset_ops.repeat_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        count=self._count,\n        **self._flat_structure)\n    super(RepeatDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass RangeDataset(DatasetSource):\n  \"\"\"A `Dataset` of a step separated range of values.\"\"\"\n\n  def __init__(self, *args, **kwargs):\n    \"\"\"See `Dataset.range()` for details.\"\"\"\n    self._parse_args(*args, **kwargs)\n    self._structure = tensor_spec.TensorSpec([], self._output_type)\n    variant_tensor = gen_dataset_ops.range_dataset(\n        start=self._start,\n        stop=self._stop,\n        step=self._step,\n        **self._flat_structure)\n    super(RangeDataset, self).__init__(variant_tensor)\n\n  def _parse_args(self, *args, **kwargs):\n    \"\"\"Parse arguments according to the same rules as the `range()` builtin.\"\"\"\n    if len(args) == 1:\n      self._start = self._build_tensor(0, \"start\")\n      self._stop = self._build_tensor(args[0], \"stop\")\n      self._step = self._build_tensor(1, \"step\")\n    elif len(args) == 2:\n      self._start = self._build_tensor(args[0], \"start\")\n      self._stop = self._build_tensor(args[1], \"stop\")\n      self._step = self._build_tensor(1, \"step\")\n    elif len(args) == 3:\n      self._start = self._build_tensor(args[0], \"start\")\n      self._stop = self._build_tensor(args[1], \"stop\")\n      self._step = self._build_tensor(args[2], \"step\")\n    else:\n      raise ValueError(\"Invalid arguments to RangeDataset: %s\" % str(args))\n    if \"output_type\" in kwargs:\n      self._output_type = kwargs[\"output_type\"]\n    else:\n      self._output_type = dtypes.int64\n\n  def _build_tensor(self, int64_value, name):\n    return ops.convert_to_tensor(int64_value, dtype=dtypes.int64, name=name)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\n# This can be deleted after the forward compatibility window for switching\n# to using dummy resource expires on 5/20.\nclass _MemoryCacheDeleter(object):\n  \"\"\"An object which cleans up an anonymous memory cache resource.\n\n  An alternative to defining a __del__ method on an object. Even if the parent\n  object is part of a reference cycle, the cycle will be collectable.\n  \"\"\"\n\n  def __init__(self, handle, device, deleter):\n    self._deleter = deleter\n    self._handle = handle\n    self._device = device\n    self._eager_mode = context.executing_eagerly()\n\n  def __del__(self):\n    with ops.device(self._device):\n      # Make sure the resource is deleted in the same mode as it was created in.\n      if self._eager_mode:\n        with context.eager_mode():\n          gen_dataset_ops.delete_memory_cache(\n              handle=self._handle, deleter=self._deleter)\n      else:\n        with context.graph_mode():\n          gen_dataset_ops.delete_memory_cache(\n              handle=self._handle, deleter=self._deleter)\n\n\n# This can be deleted after the forward compatibility window for switching\n# to using dummy resource expires on 5/20.\nclass _MemoryCache(object):\n  \"\"\"Represents a memory cache resource.\"\"\"\n\n  def __init__(self):\n    super(_MemoryCache, self).__init__()\n    if compat.forward_compatible(2020, 5, 20):\n      self._handle = gen_dataset_ops.dummy_memory_cache()\n    else:\n      self._device = context.context().device_name\n      self._handle, self._deleter = gen_dataset_ops.anonymous_memory_cache()\n      self._resource_deleter = _MemoryCacheDeleter(\n          handle=self._handle, device=self._device, deleter=self._deleter)\n\n  @property\n  def handle(self):\n    return self._handle\n\n\nclass CacheDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that caches elements of its input.\"\"\"\n\n  def __init__(self, input_dataset, filename):\n    \"\"\"See `Dataset.cache()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._filename = ops.convert_to_tensor(\n        filename, dtype=dtypes.string, name=\"filename\")\n    if tf2.enabled() and (context.executing_eagerly() or ops.inside_function()):\n      self._cache = _MemoryCache()\n      variant_tensor = gen_dataset_ops.cache_dataset_v2(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          filename=self._filename,\n          cache=self._cache.handle,\n          **self._flat_structure)\n    else:\n      variant_tensor = gen_dataset_ops.cache_dataset(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          filename=self._filename,\n          **self._flat_structure)\n    super(CacheDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass _RandomSeedGeneratorDeleter(object):\n  \"\"\"An object which cleans up an anonymous random seed generator resource.\n\n  An alternative to defining a __del__ method on an object. Even if the parent\n  object is part of a reference cycle, the cycle will be collectable.\n  \"\"\"\n\n  def __init__(self, handle, device, deleter):\n    self._deleter = deleter\n    self._handle = handle\n    self._device = device\n    self._eager_mode = context.executing_eagerly()\n\n  def __del__(self):\n    with ops.device(self._device):\n      # Make sure the resource is deleted in the same mode as it was created in.\n      if self._eager_mode:\n        with context.eager_mode():\n          gen_dataset_ops.delete_random_seed_generator(\n              handle=self._handle, deleter=self._deleter)\n      else:\n        with context.graph_mode():\n          gen_dataset_ops.delete_random_seed_generator(\n              handle=self._handle, deleter=self._deleter)\n\n\nclass _RandomSeedGenerator(object):\n  \"\"\"Represents a random seed generator resource.\"\"\"\n\n  def __init__(self, seed, seed2):\n    super(_RandomSeedGenerator, self).__init__()\n    self._device = context.context().device_name\n    self._handle, self._deleter = (\n        gen_dataset_ops.anonymous_random_seed_generator(seed=seed, seed2=seed2))\n    self._resource_deleter = _RandomSeedGeneratorDeleter(\n        handle=self._handle, device=self._device, deleter=self._deleter)\n\n  @property\n  def handle(self):\n    return self._handle\n\n\nclass ShuffleDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that randomly shuffles the elements of its input.\"\"\"\n\n  def __init__(self,\n               input_dataset,\n               buffer_size,\n               seed=None,\n               reshuffle_each_iteration=None):\n    \"\"\"Randomly shuffles the elements of this dataset.\n\n    Args:\n      input_dataset: The input dataset.\n      buffer_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\n        elements from this dataset from which the new dataset will sample.\n      seed: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the random\n        seed that will be used to create the distribution. See\n        `tf.random.set_seed` for behavior.\n      reshuffle_each_iteration: (Optional.) A boolean, which if true indicates\n        that the dataset should be pseudorandomly reshuffled each time it is\n        iterated over. (Defaults to `True`.)\n\n    Returns:\n      A `Dataset`.\n\n    Raises:\n      ValueError: if invalid arguments are provided.\n    \"\"\"\n    self._input_dataset = input_dataset\n    self._buffer_size = ops.convert_to_tensor(\n        buffer_size, dtype=dtypes.int64, name=\"buffer_size\")\n    self._seed, self._seed2 = random_seed.get_seed(seed)\n\n    if reshuffle_each_iteration is None:\n      self._reshuffle_each_iteration = True\n    else:\n      self._reshuffle_each_iteration = reshuffle_each_iteration\n\n    if tf2.enabled() and self._reshuffle_each_iteration and (\n        context.executing_eagerly() or ops.inside_function()):\n      self._seed_generator = _RandomSeedGenerator(self._seed, self._seed2)\n      variant_tensor = gen_dataset_ops.shuffle_dataset_v2(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          buffer_size=self._buffer_size,\n          seed_generator=self._seed_generator.handle,\n          **self._flat_structure)\n    else:\n      variant_tensor = gen_dataset_ops.shuffle_dataset(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          buffer_size=self._buffer_size,\n          seed=self._seed,\n          seed2=self._seed2,\n          reshuffle_each_iteration=self._reshuffle_each_iteration,\n          **self._flat_structure)\n    super(ShuffleDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass TakeDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` containing the first `count` elements from its input.\"\"\"\n\n  def __init__(self, input_dataset, count):\n    \"\"\"See `Dataset.take()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._count = ops.convert_to_tensor(count, dtype=dtypes.int64, name=\"count\")\n    variant_tensor = gen_dataset_ops.take_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        count=self._count,\n        **self._flat_structure)\n    super(TakeDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass SkipDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` skipping the first `count` elements from its input.\"\"\"\n\n  def __init__(self, input_dataset, count):\n    \"\"\"See `Dataset.skip()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._count = ops.convert_to_tensor(count, dtype=dtypes.int64, name=\"count\")\n    variant_tensor = gen_dataset_ops.skip_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        count=self._count,\n        **self._flat_structure)\n    super(SkipDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass ShardDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` for sharding its input.\"\"\"\n\n  def __init__(self, input_dataset, num_shards, index):\n    \"\"\"See `Dataset.shard()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._num_shards = ops.convert_to_tensor(\n        num_shards, dtype=dtypes.int64, name=\"num_shards\")\n    self._index = ops.convert_to_tensor(index, dtype=dtypes.int64, name=\"index\")\n    variant_tensor = gen_dataset_ops.shard_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        num_shards=self._num_shards,\n        index=self._index,\n        **self._flat_structure)\n    super(ShardDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass BatchDataset(UnaryDataset):\n  \"\"\"A `Dataset` that batches contiguous elements from its input.\"\"\"\n\n  def __init__(self, input_dataset, batch_size, drop_remainder):\n    \"\"\"See `Dataset.batch()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._batch_size = ops.convert_to_tensor(\n        batch_size, dtype=dtypes.int64, name=\"batch_size\")\n    self._drop_remainder = ops.convert_to_tensor(\n        drop_remainder, dtype=dtypes.bool, name=\"drop_remainder\")\n\n    constant_drop_remainder = tensor_util.constant_value(self._drop_remainder)\n    # pylint: disable=protected-access\n    if constant_drop_remainder:\n      # NOTE(mrry): `constant_drop_remainder` may be `None` (unknown statically)\n      # or `False` (explicitly retaining the remainder).\n      # pylint: disable=g-long-lambda\n      constant_batch_size = tensor_util.constant_value(self._batch_size)\n      self._structure = nest.map_structure(\n          lambda component_spec: component_spec._batch(constant_batch_size),\n          input_dataset.element_spec)\n    else:\n      self._structure = nest.map_structure(\n          lambda component_spec: component_spec._batch(None),\n          input_dataset.element_spec)\n    variant_tensor = gen_dataset_ops.batch_dataset_v2(\n        input_dataset._variant_tensor,\n        batch_size=self._batch_size,\n        drop_remainder=self._drop_remainder,\n        **self._flat_structure)\n    super(BatchDataset, self).__init__(input_dataset, variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass _NumpyIterator(object):\n  \"\"\"Iterator over a dataset with elements converted to numpy.\"\"\"\n\n  def __init__(self, dataset):\n    self._iterator = iter(dataset)\n\n  def __iter__(self):\n    return self\n\n  def next(self):\n    return nest.map_structure(lambda x: x.numpy(), next(self._iterator))\n\n  def __next__(self):\n    return self.next()\n\n\nclass _VariantTracker(tracking.CapturableResource):\n  \"\"\"Allows export of functions capturing a Dataset in SavedModels.\n\n  When saving a SavedModel, `tf.saved_model.save` traverses the object\n  graph. Since Datasets reference _VariantTracker objects, that traversal will\n  find a _VariantTracker for each Dataset and so know how to save and restore\n  functions which reference the Dataset's variant Tensor.\n  \"\"\"\n\n  def __init__(self, variant_tensor, resource_creator):\n    \"\"\"Record that `variant_tensor` is associated with `resource_creator`.\n\n    Args:\n      variant_tensor: The variant-dtype Tensor associated with the Dataset. This\n        Tensor will be a captured input to functions which use the Dataset, and\n        is used by saving code to identify the corresponding _VariantTracker.\n      resource_creator: A zero-argument function which creates a new\n        variant-dtype Tensor. This function will be included in SavedModels and\n        run to re-create the Dataset's variant Tensor on restore.\n    \"\"\"\n    super(_VariantTracker, self).__init__(device=\"CPU\")\n    self._resource_handle = variant_tensor\n    self._create_resource = resource_creator\n\n\ndef _is_padded_shape_compatible_with(padded_shape, input_component_shape):\n  \"\"\"Returns `True` if `input_component_shape` can be padded to `padded_shape`.\n\n  Args:\n    padded_shape: A `tf.TensorShape`.\n    input_component_shape: A `tf.TensorShape`.\n\n  Returns:\n    `True` if `input_component_shape` can be padded to `padded_shape`, otherwise\n    `False`.\n  \"\"\"\n\n  if padded_shape.dims is None or input_component_shape.dims is None:\n    return True\n  if len(padded_shape.dims) != len(input_component_shape.dims):\n    return False\n  for padded_dim, input_dim in zip(\n      padded_shape.dims, input_component_shape.dims):\n    if (padded_dim.value is not None and input_dim.value is not None\n        and padded_dim.value < input_dim.value):\n      return False\n  return True\n\n\ndef _padded_shape_to_tensor(padded_shape, input_component_shape):\n  \"\"\"Converts `padded_shape` to a `tf.Tensor` representing that shape.\n\n  Args:\n    padded_shape: A shape-like object, which may be a `tf.TensorShape`, a Python\n      sequence, or a 1-D `tf.Tensor` of `tf.int64` elements.\n    input_component_shape: A `tf.TensorShape`, with which `padded_shape` must\n      be compatible.\n\n  Returns:\n    A 1-D `tf.Tensor` of `tf.int64` elements, representing `padded_shape`.\n\n  Raises:\n    ValueError: If `padded_shape` is not a shape or not compatible with\n      `input_component_shape`.\n    TypeError: If `padded_shape` is not convertible to a `tf.int64` tensor.\n  \"\"\"\n  try:\n    # Try to convert the `padded_shape` to a `tf.TensorShape`\n    padded_shape_as_shape = tensor_shape.as_shape(padded_shape)\n    # We will return the \"canonical\" tensor representation, which uses\n    # `-1` in place of `None`.\n    ret = ops.convert_to_tensor(\n        [dim if dim is not None else -1\n         for dim in padded_shape_as_shape.as_list()], dtype=dtypes.int64)\n  except (TypeError, ValueError):\n    # The argument was not trivially convertible to a\n    # `tf.TensorShape`, so fall back on the conversion to tensor\n    # machinery.\n    ret = ops.convert_to_tensor(padded_shape, preferred_dtype=dtypes.int64)\n    if ret.shape.dims is not None and len(ret.shape.dims) != 1:\n      six.reraise(ValueError, ValueError(\n          \"Padded shape %s must be a 1-D tensor of tf.int64 values, but its \"\n          \"shape was %s.\" % (padded_shape, ret.shape)), sys.exc_info()[2])\n    if ret.dtype != dtypes.int64:\n      six.reraise(\n          TypeError,\n          TypeError(\n              \"Padded shape %s must be a 1-D tensor of tf.int64 values, but \"\n              \"its element type was %s.\" % (padded_shape, ret.dtype.name)),\n          sys.exc_info()[2])\n    padded_shape_as_shape = tensor_util.constant_value_as_shape(ret)\n\n  if not _is_padded_shape_compatible_with(padded_shape_as_shape,\n                                          input_component_shape):\n    raise ValueError(\"The padded shape %s is not compatible with the \"\n                     \"corresponding input component shape %s.\"\n                     % (padded_shape_as_shape, input_component_shape))\n\n  return ret\n\n\ndef _padding_value_to_tensor(value, output_type):\n  \"\"\"Converts the padding value to a tensor.\n\n  Args:\n    value: The padding value.\n    output_type: Its expected dtype.\n\n  Returns:\n    A scalar `Tensor`.\n\n  Raises:\n    ValueError: if the padding value is not a scalar.\n    TypeError: if the padding value's type does not match `output_type`.\n  \"\"\"\n  value = ops.convert_to_tensor(value, name=\"padding_value\")\n  if not value.shape.is_compatible_with(tensor_shape.TensorShape([])):\n    raise ValueError(\"Padding value should be a scalar, but is not: %s\" % value)\n  if value.dtype != output_type:\n    raise TypeError(\"Padding value tensor (%s) does not match output type: %s\" %\n                    (value, output_type))\n  return value\n\n\ndef _padding_values_or_default(padding_values, input_dataset):\n  \"\"\"Returns padding values with None elements replaced with default values.\"\"\"\n\n  def make_zero(t):\n    if t.base_dtype == dtypes.string:\n      return \"\"\n    elif t.base_dtype == dtypes.variant:\n      error_msg = (\"Unable to create padding for field of type 'variant' \"\n                   \"because t.base_type == dtypes.variant == \"\n                   \"{}.\".format(t.base_dtype))\n      raise TypeError(error_msg)\n    elif t.base_dtype == dtypes.bfloat16:\n      # Special case `bfloat16` because it is not supported by NumPy.\n      return constant_op.constant(0, dtype=dtypes.bfloat16)\n    else:\n      return np.zeros_like(t.as_numpy_dtype())\n\n  def value_or_default(value, default):\n    return default if value is None else value\n\n  default_padding = nest.map_structure(\n      make_zero,\n      get_legacy_output_types(input_dataset))\n  return nest.map_structure_up_to(padding_values, value_or_default,\n                                  padding_values, default_padding)\n\n\nclass PaddedBatchDataset(UnaryDataset):\n  \"\"\"A `Dataset` that batches and pads contiguous elements from its input.\"\"\"\n\n  def __init__(self, input_dataset, batch_size, padded_shapes, padding_values,\n               drop_remainder):\n    \"\"\"See `Dataset.batch()` for details.\"\"\"\n    self._input_dataset = input_dataset\n\n    def check_types(component_spec):\n      if not isinstance(component_spec, tensor_spec.TensorSpec):\n        raise TypeError(\"Padded batching of components of type \",\n                        type(component_spec), \" is not supported.\")\n\n    nest.map_structure(check_types, input_dataset.element_spec)\n    self._input_dataset = input_dataset\n    self._batch_size = ops.convert_to_tensor(\n        batch_size, dtype=dtypes.int64, name=\"batch_size\")\n    padding_values = _padding_values_or_default(padding_values, input_dataset)\n\n    input_shapes = get_legacy_output_shapes(input_dataset)\n    flat_padded_shapes = nest.flatten_up_to(input_shapes, padded_shapes)\n\n    flat_padded_shapes_as_tensors = []\n\n    for input_component_shape, padded_shape in zip(\n        nest.flatten(input_shapes), flat_padded_shapes):\n      flat_padded_shapes_as_tensors.append(\n          _padded_shape_to_tensor(padded_shape, input_component_shape))\n\n    self._padded_shapes = nest.pack_sequence_as(input_shapes,\n                                                flat_padded_shapes_as_tensors)\n\n    self._padding_values = nest.map_structure_up_to(\n        input_shapes, _padding_value_to_tensor, padding_values,\n        get_legacy_output_types(input_dataset))\n    self._drop_remainder = ops.convert_to_tensor(\n        drop_remainder, dtype=dtypes.bool, name=\"drop_remainder\")\n\n    def _padded_shape_to_batch_shape(s):\n      return tensor_shape.TensorShape([\n          tensor_util.constant_value(self._batch_size)\n          if smart_cond.smart_constant_value(self._drop_remainder) else None\n      ]).concatenate(tensor_util.constant_value_as_shape(s))\n\n    output_shapes = nest.map_structure(\n        _padded_shape_to_batch_shape, self._padded_shapes)\n    self._structure = structure.convert_legacy_structure(\n        get_legacy_output_types(self._input_dataset), output_shapes,\n        get_legacy_output_classes(self._input_dataset))\n\n    # pylint: disable=protected-access\n    # TODO(jsimsa): Switch to using v2 only any time after 6/30/2018.\n    if smart_cond.smart_constant_value(self._drop_remainder) is False:\n      variant_tensor = gen_dataset_ops.padded_batch_dataset(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          batch_size=self._batch_size,\n          padded_shapes=[\n              ops.convert_to_tensor(s, dtype=dtypes.int64)\n              for s in nest.flatten(self._padded_shapes)\n          ],\n          padding_values=nest.flatten(self._padding_values),\n          output_shapes=structure.get_flat_tensor_shapes(self._structure))\n    else:\n      variant_tensor = gen_dataset_ops.padded_batch_dataset_v2(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          batch_size=self._batch_size,\n          padded_shapes=[\n              ops.convert_to_tensor(s, dtype=dtypes.int64)\n              for s in nest.flatten(self._padded_shapes)\n          ],\n          padding_values=nest.flatten(self._padding_values),\n          drop_remainder=self._drop_remainder,\n          output_shapes=structure.get_flat_tensor_shapes(self._structure))\n    super(PaddedBatchDataset, self).__init__(input_dataset, variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\ndef _should_unpack_args(args):\n  \"\"\"Returns `True` if `args` should be `*args` when passed to a callable.\"\"\"\n  return type(args) is tuple  # pylint: disable=unidiomatic-typecheck\n\n\nclass MapDataset(UnaryDataset):\n  \"\"\"A `Dataset` that maps a function over elements in its input.\"\"\"\n\n  def __init__(self,\n               input_dataset,\n               map_func,\n               use_inter_op_parallelism=True,\n               preserve_cardinality=False,\n               use_legacy_function=False):\n    \"\"\"See `Dataset.map()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._use_inter_op_parallelism = use_inter_op_parallelism\n    self._preserve_cardinality = preserve_cardinality\n    self._map_func = StructuredFunctionWrapper(\n        map_func,\n        self._transformation_name(),\n        dataset=input_dataset,\n        use_legacy_function=use_legacy_function)\n    variant_tensor = gen_dataset_ops.map_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._map_func.function.captured_inputs,\n        f=self._map_func.function,\n        use_inter_op_parallelism=self._use_inter_op_parallelism,\n        preserve_cardinality=self._preserve_cardinality,\n        **self._flat_structure)\n    super(MapDataset, self).__init__(input_dataset, variant_tensor)\n\n  def _functions(self):\n    return [self._map_func]\n\n  @property\n  def element_spec(self):\n    return self._map_func.output_structure\n\n  def _transformation_name(self):\n    return \"Dataset.map()\"\n\n\nclass ParallelMapDataset(UnaryDataset):\n  \"\"\"A `Dataset` that maps a function over elements in its input in parallel.\"\"\"\n\n  def __init__(self,\n               input_dataset,\n               map_func,\n               num_parallel_calls,\n               deterministic,\n               use_inter_op_parallelism=True,\n               preserve_cardinality=False,\n               use_legacy_function=False):\n    \"\"\"See `Dataset.map()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._use_inter_op_parallelism = use_inter_op_parallelism\n    self._map_func = StructuredFunctionWrapper(\n        map_func,\n        self._transformation_name(),\n        dataset=input_dataset,\n        use_legacy_function=use_legacy_function)\n    if deterministic is None:\n      self._deterministic = \"default\"\n    elif deterministic:\n      self._deterministic = \"true\"\n    else:\n      self._deterministic = \"false\"\n    self._preserve_cardinality = preserve_cardinality\n    if deterministic is not None or compat.forward_compatible(2020, 3, 6):\n      self._num_parallel_calls = ops.convert_to_tensor(\n          num_parallel_calls, dtype=dtypes.int64, name=\"num_parallel_calls\")\n      variant_tensor = gen_dataset_ops.parallel_map_dataset_v2(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          self._map_func.function.captured_inputs,\n          f=self._map_func.function,\n          num_parallel_calls=self._num_parallel_calls,\n          deterministic=self._deterministic,\n          use_inter_op_parallelism=self._use_inter_op_parallelism,\n          preserve_cardinality=self._preserve_cardinality,\n          **self._flat_structure)\n    else:\n      self._num_parallel_calls = ops.convert_to_tensor(\n          num_parallel_calls, dtype=dtypes.int32, name=\"num_parallel_calls\")\n      variant_tensor = gen_dataset_ops.parallel_map_dataset(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          self._map_func.function.captured_inputs,\n          f=self._map_func.function,\n          num_parallel_calls=self._num_parallel_calls,\n          use_inter_op_parallelism=self._use_inter_op_parallelism,\n          preserve_cardinality=self._preserve_cardinality,\n          **self._flat_structure)\n    super(ParallelMapDataset, self).__init__(input_dataset, variant_tensor)\n\n  def _functions(self):\n    return [self._map_func]\n\n  @property\n  def element_spec(self):\n    return self._map_func.output_structure\n\n  def _transformation_name(self):\n    return \"Dataset.map()\"\n\n\nclass FlatMapDataset(UnaryDataset):\n  \"\"\"A `Dataset` that maps a function over its input and flattens the result.\"\"\"\n\n  def __init__(self, input_dataset, map_func):\n    \"\"\"See `Dataset.flat_map()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._map_func = StructuredFunctionWrapper(\n        map_func, self._transformation_name(), dataset=input_dataset)\n    if not isinstance(self._map_func.output_structure, DatasetSpec):\n      raise TypeError(\n          \"`map_func` must return a `Dataset` object. Got {}\".format(\n              type(self._map_func.output_structure)))\n    self._structure = self._map_func.output_structure._element_spec  # pylint: disable=protected-access\n    variant_tensor = gen_dataset_ops.flat_map_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._map_func.function.captured_inputs,\n        f=self._map_func.function,\n        **self._flat_structure)\n    super(FlatMapDataset, self).__init__(input_dataset, variant_tensor)\n\n  def _functions(self):\n    return [self._map_func]\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n  def _transformation_name(self):\n    return \"Dataset.flat_map()\"\n\n\nclass InterleaveDataset(UnaryDataset):\n  \"\"\"A `Dataset` that interleaves the result of transformed inputs.\"\"\"\n\n  def __init__(self, input_dataset, map_func, cycle_length, block_length):\n    \"\"\"See `Dataset.interleave()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._map_func = StructuredFunctionWrapper(\n        map_func, self._transformation_name(), dataset=input_dataset)\n    if not isinstance(self._map_func.output_structure, DatasetSpec):\n      raise TypeError(\n          \"`map_func` must return a `Dataset` object. Got {}\".format(\n              type(self._map_func.output_structure)))\n    self._structure = self._map_func.output_structure._element_spec  # pylint: disable=protected-access\n    self._cycle_length = ops.convert_to_tensor(\n        cycle_length, dtype=dtypes.int64, name=\"cycle_length\")\n    self._block_length = ops.convert_to_tensor(\n        block_length, dtype=dtypes.int64, name=\"block_length\")\n\n    variant_tensor = gen_dataset_ops.interleave_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._map_func.function.captured_inputs,  # pylint: disable=protected-access\n        self._cycle_length,\n        self._block_length,\n        f=self._map_func.function,\n        **self._flat_structure)\n    super(InterleaveDataset, self).__init__(input_dataset, variant_tensor)\n\n  def _functions(self):\n    return [self._map_func]\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n  def _transformation_name(self):\n    return \"Dataset.interleave()\"\n\n\nclass ParallelInterleaveDataset(UnaryDataset):\n  \"\"\"A `Dataset` that maps a function over its input and interleaves the result.\"\"\"\n\n  def __init__(self,\n               input_dataset,\n               map_func,\n               cycle_length,\n               block_length,\n               num_parallel_calls,\n               buffer_output_elements=AUTOTUNE,\n               prefetch_input_elements=AUTOTUNE,\n               deterministic=None):\n    \"\"\"See `Dataset.interleave()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    self._map_func = StructuredFunctionWrapper(\n        map_func, self._transformation_name(), dataset=input_dataset)\n    if not isinstance(self._map_func.output_structure, DatasetSpec):\n      raise TypeError(\n          \"`map_func` must return a `Dataset` object. Got {}\".format(\n              type(self._map_func.output_structure)))\n    self._structure = self._map_func.output_structure._element_spec  # pylint: disable=protected-access\n    self._cycle_length = ops.convert_to_tensor(\n        cycle_length, dtype=dtypes.int64, name=\"cycle_length\")\n    self._block_length = ops.convert_to_tensor(\n        block_length, dtype=dtypes.int64, name=\"block_length\")\n    self._buffer_output_elements = ops.convert_to_tensor(\n        buffer_output_elements,\n        dtype=dtypes.int64,\n        name=\"buffer_output_elements\")\n    self._prefetch_input_elements = ops.convert_to_tensor(\n        prefetch_input_elements,\n        dtype=dtypes.int64,\n        name=\"prefetch_input_elements\")\n\n    self._num_parallel_calls = ops.convert_to_tensor(\n        num_parallel_calls, dtype=dtypes.int64, name=\"num_parallel_calls\")\n    if deterministic is None:\n      deterministic_string = \"default\"\n    elif deterministic:\n      deterministic_string = \"true\"\n    else:\n      deterministic_string = \"false\"\n\n    if (buffer_output_elements != AUTOTUNE or\n        prefetch_input_elements != AUTOTUNE or\n        compat.forward_compatible(2020, 3, 6)):\n      variant_tensor = gen_dataset_ops.parallel_interleave_dataset_v4(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          self._map_func.function.captured_inputs,  # pylint: disable=protected-access\n          self._cycle_length,\n          self._block_length,\n          self._buffer_output_elements,\n          self._prefetch_input_elements,\n          self._num_parallel_calls,\n          f=self._map_func.function,\n          deterministic=deterministic_string,\n          **self._flat_structure)\n    elif deterministic is not None or compat.forward_compatible(2020, 2, 20):\n      variant_tensor = gen_dataset_ops.parallel_interleave_dataset_v3(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          self._map_func.function.captured_inputs,  # pylint: disable=protected-access\n          self._cycle_length,\n          self._block_length,\n          self._num_parallel_calls,\n          f=self._map_func.function,\n          deterministic=deterministic_string,\n          **self._flat_structure)\n    else:\n      variant_tensor = gen_dataset_ops.parallel_interleave_dataset_v2(\n          input_dataset._variant_tensor,  # pylint: disable=protected-access\n          self._map_func.function.captured_inputs,  # pylint: disable=protected-access\n          self._cycle_length,\n          self._block_length,\n          self._num_parallel_calls,\n          f=self._map_func.function,\n          **self._flat_structure)\n    super(ParallelInterleaveDataset, self).__init__(input_dataset,\n                                                    variant_tensor)\n\n  def _functions(self):\n    return [self._map_func]\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n  def _transformation_name(self):\n    return \"Dataset.interleave()\"\n\n\nclass FilterDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that filters its input according to a predicate function.\"\"\"\n\n  def __init__(self, input_dataset, predicate, use_legacy_function=False):\n    \"\"\"See `Dataset.filter()` for details.\"\"\"\n    self._input_dataset = input_dataset\n    wrapped_func = StructuredFunctionWrapper(\n        predicate,\n        self._transformation_name(),\n        dataset=input_dataset,\n        use_legacy_function=use_legacy_function)\n    if not wrapped_func.output_structure.is_compatible_with(\n        tensor_spec.TensorSpec([], dtypes.bool)):\n      error_msg = (\"`predicate` return type must be convertible to a scalar \"\n                   \"boolean tensor. Was {}.\").format(\n                       wrapped_func.output_structure)\n      raise ValueError(error_msg)\n    self._predicate = wrapped_func\n    variant_tensor = gen_dataset_ops.filter_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        other_arguments=self._predicate.function.captured_inputs,\n        predicate=self._predicate.function,\n        **self._flat_structure)\n    super(FilterDataset, self).__init__(input_dataset, variant_tensor)\n\n  def _functions(self):\n    return [self._predicate]\n\n  def _transformation_name(self):\n    return \"Dataset.filter()\"\n\n\nclass PrefetchDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that asynchronously prefetches its input.\"\"\"\n\n  def __init__(self, input_dataset, buffer_size, slack_period=None):\n    \"\"\"See `Dataset.prefetch()` for details.\n\n    Args:\n      input_dataset: The input dataset.\n      buffer_size: See `Dataset.prefetch()` for details.\n      slack_period: (Optional.) An integer. If non-zero, determines the number\n        of GetNext calls before injecting slack into the execution. This may\n        reduce CPU contention at the start of a step. Note that a tensorflow\n        user should not have to set this manually; enable this behavior\n        automatically via `tf.data.Options.experimental_slack` instead. Defaults\n        to None.\n    \"\"\"\n    self._input_dataset = input_dataset\n    if buffer_size is None:\n      buffer_size = -1  # This is the sentinel for auto-tuning.\n    self._buffer_size = ops.convert_to_tensor(\n        buffer_size, dtype=dtypes.int64, name=\"buffer_size\")\n    variant_tensor = gen_dataset_ops.prefetch_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        buffer_size=self._buffer_size,\n        slack_period=slack_period,\n        **self._flat_structure)\n    super(PrefetchDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass WindowDataset(UnaryDataset):\n  \"\"\"A dataset that creates window datasets from the input elements.\"\"\"\n\n  def __init__(self, input_dataset, size, shift, stride, drop_remainder):\n    \"\"\"See `window_dataset()` for more details.\"\"\"\n    self._input_dataset = input_dataset\n    self._size = ops.convert_to_tensor(size, dtype=dtypes.int64, name=\"size\")\n    self._shift = ops.convert_to_tensor(shift, dtype=dtypes.int64, name=\"shift\")\n    self._stride = ops.convert_to_tensor(\n        stride, dtype=dtypes.int64, name=\"stride\")\n    self._drop_remainder = ops.convert_to_tensor(\n        drop_remainder, dtype=dtypes.bool, name=\"drop_remainder\")\n    self._structure = nest.pack_sequence_as(\n        get_legacy_output_classes(input_dataset), [\n            DatasetSpec(  # pylint: disable=g-complex-comprehension\n                structure.convert_legacy_structure(\n                    output_type, output_shape, output_class))\n            for output_class, output_shape, output_type in zip(\n                nest.flatten(get_legacy_output_classes(input_dataset)),\n                nest.flatten(get_legacy_output_shapes(input_dataset)),\n                nest.flatten(get_legacy_output_types(input_dataset)))\n        ])\n    variant_tensor = gen_dataset_ops.window_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._size,\n        self._shift,\n        self._stride,\n        self._drop_remainder,\n        **self._flat_structure)\n    super(WindowDataset, self).__init__(input_dataset, variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass _OptionsDataset(UnaryUnchangedStructureDataset):\n  \"\"\"An identity `Dataset` that stores options.\"\"\"\n\n  def __init__(self, input_dataset, options):\n    self._input_dataset = input_dataset\n    self._options = input_dataset.options()\n    if self._options:\n      self._options = self._options.merge(options)\n    else:\n      self._options = options\n    variant_tensor = input_dataset._variant_tensor  # pylint: disable=protected-access\n    super(_OptionsDataset, self).__init__(input_dataset, variant_tensor)\n\n  def options(self):\n    return self._options\n\n\nclass _ModelDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that acts as an identity, and models performance.\"\"\"\n\n  def __init__(self, input_dataset, algorithm, cpu_budget):\n    self._input_dataset = input_dataset\n    variant_tensor = gen_dataset_ops.model_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        algorithm=algorithm.value,\n        cpu_budget=cpu_budget,\n        **self._flat_structure)\n    super(_ModelDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass _OptimizeDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that acts as an identity, and applies optimizations.\"\"\"\n\n  def __init__(self, input_dataset, optimizations, optimization_configs=None):\n    self._input_dataset = input_dataset\n    if optimizations is None:\n      optimizations = []\n    if optimization_configs is None:\n      optimization_configs = []\n    self._optimizations = ops.convert_to_tensor(\n        optimizations, dtype=dtypes.string, name=\"optimizations\")\n    variant_tensor = gen_dataset_ops.optimize_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._optimizations,\n        optimization_configs=optimization_configs,\n        **self._flat_structure)\n    super(_OptimizeDataset, self).__init__(input_dataset, variant_tensor)\n\n\nclass _SetStatsAggregatorDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that acts as an identity, and sets a stats aggregator.\"\"\"\n\n  def __init__(self, input_dataset, aggregator, prefix, counter_prefix):\n    self._input_dataset = input_dataset\n    self._stats_aggregator = aggregator\n    self._prefix = prefix\n    self._counter_prefix = counter_prefix\n    variant_tensor = ged_ops.set_stats_aggregator_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._stats_aggregator._resource,  # pylint: disable=protected-access\n        self._prefix,\n        self._counter_prefix,\n        **self._flat_structure)\n    super(_SetStatsAggregatorDataset, self).__init__(input_dataset,\n                                                     variant_tensor)\n\n\nclass _MaxIntraOpParallelismDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that acts as an identity, overriding intra-op parallelism.\"\"\"\n\n  def __init__(self, input_dataset, max_intra_op_parallelism):\n    self._input_dataset = input_dataset\n    self._max_intra_op_parallelism = ops.convert_to_tensor(\n        max_intra_op_parallelism,\n        dtype=dtypes.int64,\n        name=\"max_intra_op_parallelism\")\n    variant_tensor = ged_ops.max_intra_op_parallelism_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._max_intra_op_parallelism,\n        **self._flat_structure)\n    super(_MaxIntraOpParallelismDataset, self).__init__(input_dataset,\n                                                        variant_tensor)\n\n\nclass _PrivateThreadPoolDataset(UnaryUnchangedStructureDataset):\n  \"\"\"A `Dataset` that acts as an identity, setting a private threadpool.\"\"\"\n\n  def __init__(self, input_dataset, num_threads):\n    self._input_dataset = input_dataset\n    self._num_threads = ops.convert_to_tensor(\n        num_threads, dtype=dtypes.int64, name=\"num_threads\")\n    variant_tensor = ged_ops.private_thread_pool_dataset(\n        input_dataset._variant_tensor,  # pylint: disable=protected-access\n        self._num_threads,\n        **self._flat_structure)\n    super(_PrivateThreadPoolDataset, self).__init__(input_dataset,\n                                                    variant_tensor)\n\n\ndef normalize_to_dense(dataset):\n  \"\"\"Normalizes non-tensor components in a dataset to dense representations.\n\n  This is necessary for dataset transformations that slice along the batch\n  dimension and are oblivious to non-tensors, e.g. `unbatch`, `rebatch`.\n\n  Args:\n    dataset: Dataset to normalize.\n\n  Returns:\n    A dataset whose sparse and ragged tensors have been normalized to their\n    dense representations.\n  \"\"\"\n\n  # NOTE(mrry): This leads to a somewhat inefficient re-encoding step for all\n  # non-tensor components.\n  #\n  # TODO(mrry): Consider optimizing this if it turns out to be a bottleneck.\n  if _should_unpack_args(dataset.element_spec):\n    def normalize(*args):\n      return structure.to_batched_tensor_list(dataset.element_spec, tuple(args))\n  else:\n    def normalize(arg):\n      return structure.to_batched_tensor_list(dataset.element_spec, arg)\n\n  normalized_dataset = dataset.map(normalize)\n\n  # NOTE(mrry): Our `map()` has lost information about the structure of\n  # non-tensor components, so re-apply the structure of the original dataset.\n  return _RestructuredDataset(normalized_dataset, dataset.element_spec)\n\n\nclass _RestructuredDataset(UnaryDataset):\n  \"\"\"An internal helper for changing the structure and shape of a dataset.\"\"\"\n\n  def __init__(self, dataset, structure):\n    self._input_dataset = dataset\n    self._structure = structure\n\n    variant_tensor = self._input_dataset._variant_tensor  # pylint: disable=protected-access\n    super(_RestructuredDataset, self).__init__(dataset, variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\nclass _UnbatchDataset(UnaryDataset):\n  \"\"\"A dataset that splits the elements of its input into multiple elements.\"\"\"\n\n  def __init__(self, input_dataset):\n    \"\"\"See `unbatch()` for more details.\"\"\"\n    flat_shapes = input_dataset._flat_shapes  # pylint: disable=protected-access\n    if any(s.ndims == 0 for s in flat_shapes):\n      raise ValueError(\"Cannot unbatch an input with scalar components.\")\n    known_batch_dim = tensor_shape.Dimension(None)\n    for s in flat_shapes:\n      try:\n        known_batch_dim = known_batch_dim.merge_with(s[0])\n      except ValueError:\n        raise ValueError(\"Cannot unbatch an input whose components have \"\n                         \"different batch sizes.\")\n    self._input_dataset = input_dataset\n    self._structure = nest.map_structure(\n        lambda component_spec: component_spec._unbatch(),  # pylint: disable=protected-access\n        get_structure(input_dataset))\n    variant_tensor = ged_ops.unbatch_dataset(\n        self._input_dataset._variant_tensor,  # pylint: disable=protected-access\n        **self._flat_structure)\n    super(_UnbatchDataset, self).__init__(input_dataset, variant_tensor)\n\n  @property\n  def element_spec(self):\n    return self._structure\n\n\ndef _collect_resource_inputs(op):\n  \"\"\"Collects resource inputs for the given ops (and its variant inputs).\"\"\"\n\n  def _process(op_queue, seen_ops):\n    \"\"\"Processes the next element of the op queue.\n\n    Args:\n      op_queue: Queue of Dataset operations to process.\n      seen_ops: Already processed set of Operations.\n\n    Returns:\n      A 2-tuple containing sets of resource handles. The first tuple entry\n      contains read-only handles and the second entry contains read-write\n      handles.\n    \"\"\"\n\n    reads = []\n    writes = []\n    op = op_queue.pop()\n    if op in seen_ops:\n      return reads, writes\n    seen_ops.add(op)\n    # TODO(b/150139257): All resource inputs are in writes right now since we\n    # have not updated the functional ops to set the special attribute that ACD\n    # uses to figure out which of the op's inputs are read-only.\n    reads, writes = acd_utils.get_read_write_resource_inputs(op)\n    # Conservatively assume that any variant inputs are datasets.\n    op_queue.extend(t.op for t in op.inputs if t.dtype == dtypes.variant)\n    return reads, writes\n\n  op_queue = [op]\n  seen_ops = set()\n  all_reads = []\n  all_writes = []\n  while op_queue:\n    reads, writes = _process(op_queue, seen_ops)\n    all_reads.extend(reads)\n    all_writes.extend(writes)\n\n  return all_reads, all_writes\n\n\n@auto_control_deps.register_acd_resource_resolver\ndef _resource_resolver(op, resource_reads, resource_writes):\n  \"\"\"Updates resource inputs for tf.data ops with indirect dependencies.\"\"\"\n\n  updated = False\n  if op.type in [\n      \"DatasetToSingleElement\", \"DatasetToTFRecord\", \"ReduceDataset\"\n  ]:\n    reads, writes = _collect_resource_inputs(op)\n    for inp in reads:\n      if inp not in resource_reads:\n        updated = True\n        resource_reads.add(inp)\n    for inp in writes:\n      if inp not in resource_writes:\n        updated = True\n        resource_writes.add(inp)\n\n  if op.type in [\n      \"IteratorGetNext\", \"IteratorGetNextSync\", \"IteratorGetNextAsOptional\"\n  ]:\n    iterator_resource = op.inputs[0]\n    make_iterator_ops = [\n        op for op in iterator_resource.consumers() if op.type == \"MakeIterator\"\n    ]\n\n    if len(make_iterator_ops) == 1:\n      reads, writes = _collect_resource_inputs(make_iterator_ops[0])\n      for inp in reads:\n        if inp not in resource_reads:\n          updated = True\n          resource_reads.add(inp)\n      for inp in writes:\n        if inp not in resource_writes:\n          updated = True\n          resource_writes.add(inp)\n\n  return updated\n",
			"file": "venv/lib/python3.6/site-packages/tensorflow/python/data/ops/dataset_ops.py",
			"file_size": 181870,
			"file_write_time": 132394892070000000,
			"settings":
			{
				"buffer_size": 181870,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/User/python3.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				],
				[
					"Packages/User/python3.sublime-build",
					""
				],
				[
					"Packages/User/python37.sublime-build",
					""
				]
			],
			[
				"Packages/User/python3.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"inden",
				"Indentation: Reindent Lines"
			],
			[
				"indent",
				"Indentation: Reindent Lines"
			],
			[
				"ins",
				"Package Control: Install Package"
			],
			[
				"remov",
				"Package Control: Remove Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"side",
				"View: Toggle Open Files in Side Bar"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/kinga/mnt",
		"/home/kinga/mnt/analysis",
		"/home/kinga/mnt/analysis_main",
		"/home/kinga/mnt/discriminator",
		"/home/kinga/mnt/util"
	],
	"file_history":
	[
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorflow/python/data/ops/dataset_ops.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorflow/python/ops/gen_dataset_ops.py",
		"/home/kinga/mnt/util/event_sample.py",
		"/home/kinga/mnt/analysis/analysis_roc.py",
		"/home/kinga/mnt/config/config.py",
		"/home/kinga/mnt/util/plotting.py",
		"/home/kinga/mnt/tf_dataset_test.py",
		"/home/kinga/mnt/util/utility_fun.py",
		"/home/kinga/mnt/inout/event_to_image_converter.py",
		"/home/kinga/mnt/main.py",
		"/home/kinga/mnt/main_3d_vae.py",
		"/home/kinga/mnt/main_train_3d_vae.py",
		"/home/kinga/mnt/analysis_main/main_analysis_jet_features.py",
		"/home/kinga/mnt/analysis_main/main_analysis_losses.py",
		"/home/kinga/mnt/analysis_main/main_analysis_roc.py",
		"/home/kinga/mnt/playground/test_sample_path_factory.py",
		"/home/kinga/mnt/tests/test_event_sample_dump.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/backend/application.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/audio/audio_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/core/core_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/custom_scalar/custom_scalars_plugin.py",
		"/home/kinga/mnt/main_analysis_model_comparison.py",
		"/home/kinga/mnt/main_analysis_jet_features.py",
		"/home/kinga/mnt/main_analysis.py",
		"/home/kinga/mnt/main_predict_3d_vae.py",
		"/home/kinga/mnt/main_predict.py",
		"/home/kinga/mnt/vae/vae_prediction.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/text/text_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/scalar/scalars_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/pr_curve/pr_curves_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/image/images_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/hparams/list_session_groups.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/hparams/hparams_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/hparams/get_experiment.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/hparams/backend_context.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/histogram/histograms_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/graph/graphs_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/distribution/distributions_plugin.py",
		"/home/kinga/mnt/venv/lib/python3.6/site-packages/tensorboard/plugins/debugger_v2/debugger_v2_plugin.py",
		"/home/kinga/mnt/inout/sample_factory.py",
		"/home/kinga/mnt/analysis/analysis_losses.py"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 101.0,
		"where_history":
		[
			"*.py",
			"~/mnt/main(.*)",
			"~/mnt/main*",
			"~/mnt/.*/.*.py",
			"~/mnt/*/.*.py",
			"~/mnt/*/*.py",
			"~/mnt/main.*",
			"~/mnt/main*",
			"~/mnt/*main*",
			"~/mnt/*main*.py",
			"~/mnt/.*.py",
			"~/mnt",
			"~/mnt/.*.py",
			"~/mnt/*.py",
			"~/mnt/.*.py",
			"~/mnt/.*/.*.py",
			"~/mnt/*/*.py",
			"~/mnt/*.py",
			"~/mnt/*/*.py",
			"~/mnt/*.py",
			"~/mnt/analysis",
			"~/mnt/vae",
			"~/mnt",
			"~/mnt/inout",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"paths",
			"file_path.numpy().decode('utf-8').split(os.sep)[-1]",
			"file_path",
			"from",
			"from_",
			"POfAH",
			"util.experiment",
			"inout.input_data_reader",
			"inout.sample_factory",
			"util.jet_sample",
			"config.sample_dict"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"pofah",
			"POfAH.util.experiment",
			"POfAH.util.input_data_reader",
			"POfAH.util.sample_factory",
			"POfAH.jet_sample",
			"POfAH.sample_dict"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 6,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "main_train.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1493,
						"regions":
						{
						},
						"selection":
						[
							[
								126,
								126
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tabs_extra_last_activated": 1598025961.44,
							"tabs_extra_last_activated_sheet_index": 0,
							"tabs_extra_spawned": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "main_analysis_jet_features.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3835,
						"regions":
						{
						},
						"selection":
						[
							[
								929,
								929
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tabs_extra_last_activated": 1598025959.69,
							"tabs_extra_last_activated_sheet_index": 1
						},
						"translation.x": 0.0,
						"translation.y": 663.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "main_predict.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2651,
						"regions":
						{
						},
						"selection":
						[
							[
								448,
								448
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1597309710.84,
							"tabs_extra_last_activated_sheet_index": 1,
							"tabs_extra_spawned": true,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "vae/vae_model.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8390,
						"regions":
						{
						},
						"selection":
						[
							[
								7186,
								7186
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1597309707.76,
							"tabs_extra_last_activated_sheet_index": 2,
							"tabs_extra_spawned": true,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1887.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "main_analysis_model_comparison.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2383,
						"regions":
						{
						},
						"selection":
						[
							[
								671,
								671
							],
							[
								952,
								952
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1598472739.58,
							"tabs_extra_last_activated_sheet_index": 4,
							"tabs_extra_spawned": true,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "analysis/analysis_losses.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1648,
						"regions":
						{
						},
						"selection":
						[
							[
								281,
								281
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1598473212.66,
							"tabs_extra_last_activated_sheet_index": 5,
							"tabs_extra_spawned": true,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "analysis/analysis_constituents.py",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 958,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1598475561.11,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "analysis_main/main_analysis_losses.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 810,
						"regions":
						{
						},
						"selection":
						[
							[
								98,
								98
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tabs_extra_last_activated": 1598472796.28,
							"tabs_extra_last_activated_sheet_index": 6,
							"tabs_extra_spawned": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "analysis_main/main_analysis_roc.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2238,
						"regions":
						{
						},
						"selection":
						[
							[
								123,
								123
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1598387615.15,
							"tabs_extra_last_activated_sheet_index": 7,
							"tabs_extra_spawned": true,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "main_train_3d_vae.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1804,
						"regions":
						{
						},
						"selection":
						[
							[
								911,
								911
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tabs_extra_last_activated": 1598109784.23,
							"tabs_extra_last_activated_sheet_index": 8
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "main_predict_3d_vae.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3613,
						"regions":
						{
						},
						"selection":
						[
							[
								309,
								309
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"tabs_extra_last_activated": 1598465400.72,
							"tabs_extra_last_activated_sheet_index": 9,
							"tabs_extra_spawned": true,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "playground/test_tf_dataset.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1264,
						"regions":
						{
						},
						"selection":
						[
							[
								1077,
								1077
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": true,
							"open_with_edit": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tabs_extra_last_activated": 1598360570.77,
							"tabs_extra_last_activated_sheet_index": 10
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "playground/tf_test.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 269,
						"regions":
						{
						},
						"selection":
						[
							[
								256,
								256
							]
						],
						"settings":
						{
							"auto_complete": false,
							"git_gutter_is_enabled": false,
							"open_with_edit": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tabs_extra_last_activated": 1598293344.24,
							"tabs_extra_last_activated_sheet_index": 11
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "venv/lib/python3.6/site-packages/tensorflow/python/data/ops/dataset_ops.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 181870,
						"regions":
						{
						},
						"selection":
						[
							[
								16160,
								16160
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 2,
							"tabs_extra_last_activated": 1598276403.99,
							"tabs_extra_last_activated_sheet_index": 12,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3997.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 38.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 320.0
	},
	"output.find_results":
	{
		"height": 120.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "Packages/User/python3.sublime-build",
	"project": "vae.sublime-project",
	"replace":
	{
		"height": 70.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 229.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
